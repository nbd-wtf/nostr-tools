{
  "version": 3,
  "sources": ["../../nip44.ts", "../../utils.ts"],
  "sourcesContent": ["import { chacha20 } from '@noble/ciphers/chacha'\nimport { equalBytes } from '@noble/ciphers/utils'\nimport { secp256k1 } from '@noble/curves/secp256k1'\nimport { extract as hkdf_extract, expand as hkdf_expand } from '@noble/hashes/hkdf'\nimport { hmac } from '@noble/hashes/hmac'\nimport { sha256 } from '@noble/hashes/sha256'\nimport { concatBytes, randomBytes } from '@noble/hashes/utils'\nimport { base64 } from '@scure/base'\n\nimport { utf8Decoder, utf8Encoder } from './utils.ts'\n\nconst minPlaintextSize = 0x0001 // 1b msg => padded to 32b\nconst maxPlaintextSize = 0xffff // 65535 (64kb-1) => padded to 64kb\n\nexport function getConversationKey(privkeyA: Uint8Array, pubkeyB: string): Uint8Array {\n  const sharedX = secp256k1.getSharedSecret(privkeyA, '02' + pubkeyB).subarray(1, 33)\n  return hkdf_extract(sha256, sharedX, 'nip44-v2')\n}\n\nfunction getMessageKeys(\n  conversationKey: Uint8Array,\n  nonce: Uint8Array,\n): { chacha_key: Uint8Array; chacha_nonce: Uint8Array; hmac_key: Uint8Array } {\n  const keys = hkdf_expand(sha256, conversationKey, nonce, 76)\n  return {\n    chacha_key: keys.subarray(0, 32),\n    chacha_nonce: keys.subarray(32, 44),\n    hmac_key: keys.subarray(44, 76),\n  }\n}\n\nfunction calcPaddedLen(len: number): number {\n  if (!Number.isSafeInteger(len) || len < 1) throw new Error('expected positive integer')\n  if (len <= 32) return 32\n  const nextPower = 1 << (Math.floor(Math.log2(len - 1)) + 1)\n  const chunk = nextPower <= 256 ? 32 : nextPower / 8\n  return chunk * (Math.floor((len - 1) / chunk) + 1)\n}\n\nfunction writeU16BE(num: number): Uint8Array {\n  if (!Number.isSafeInteger(num) || num < minPlaintextSize || num > maxPlaintextSize)\n    throw new Error('invalid plaintext size: must be between 1 and 65535 bytes')\n  const arr = new Uint8Array(2)\n  new DataView(arr.buffer).setUint16(0, num, false)\n  return arr\n}\n\nfunction pad(plaintext: string): Uint8Array {\n  const unpadded = utf8Encoder.encode(plaintext)\n  const unpaddedLen = unpadded.length\n  const prefix = writeU16BE(unpaddedLen)\n  const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen)\n  return concatBytes(prefix, unpadded, suffix)\n}\n\nfunction unpad(padded: Uint8Array): string {\n  const unpaddedLen = new DataView(padded.buffer).getUint16(0)\n  const unpadded = padded.subarray(2, 2 + unpaddedLen)\n  if (\n    unpaddedLen < minPlaintextSize ||\n    unpaddedLen > maxPlaintextSize ||\n    unpadded.length !== unpaddedLen ||\n    padded.length !== 2 + calcPaddedLen(unpaddedLen)\n  )\n    throw new Error('invalid padding')\n  return utf8Decoder.decode(unpadded)\n}\n\nfunction hmacAad(key: Uint8Array, message: Uint8Array, aad: Uint8Array): Uint8Array {\n  if (aad.length !== 32) throw new Error('AAD associated data must be 32 bytes')\n  const combined = concatBytes(aad, message)\n  return hmac(sha256, key, combined)\n}\n\n// metadata: always 65b (version: 1b, nonce: 32b, max: 32b)\n// plaintext: 1b to 0xffff\n// padded plaintext: 32b to 0xffff\n// ciphertext: 32b+2 to 0xffff+2\n// raw payload: 99 (65+32+2) to 65603 (65+0xffff+2)\n// compressed payload (base64): 132b to 87472b\nfunction decodePayload(payload: string): { nonce: Uint8Array; ciphertext: Uint8Array; mac: Uint8Array } {\n  if (typeof payload !== 'string') throw new Error('payload must be a valid string')\n  const plen = payload.length\n  if (plen < 132 || plen > 87472) throw new Error('invalid payload length: ' + plen)\n  if (payload[0] === '#') throw new Error('unknown encryption version')\n  let data: Uint8Array\n  try {\n    data = base64.decode(payload)\n  } catch (error) {\n    throw new Error('invalid base64: ' + (error as any).message)\n  }\n  const dlen = data.length\n  if (dlen < 99 || dlen > 65603) throw new Error('invalid data length: ' + dlen)\n  const vers = data[0]\n  if (vers !== 2) throw new Error('unknown encryption version ' + vers)\n  return {\n    nonce: data.subarray(1, 33),\n    ciphertext: data.subarray(33, -32),\n    mac: data.subarray(-32),\n  }\n}\n\nexport function encrypt(plaintext: string, conversationKey: Uint8Array, nonce: Uint8Array = randomBytes(32)): string {\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce)\n  const padded = pad(plaintext)\n  const ciphertext = chacha20(chacha_key, chacha_nonce, padded)\n  const mac = hmacAad(hmac_key, ciphertext, nonce)\n  return base64.encode(concatBytes(new Uint8Array([2]), nonce, ciphertext, mac))\n}\n\nexport function decrypt(payload: string, conversationKey: Uint8Array): string {\n  const { nonce, ciphertext, mac } = decodePayload(payload)\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce)\n  const calculatedMac = hmacAad(hmac_key, ciphertext, nonce)\n  if (!equalBytes(calculatedMac, mac)) throw new Error('invalid MAC')\n  const padded = chacha20(chacha_key, chacha_nonce, ciphertext)\n  return unpad(padded)\n}\n\nexport const v2 = {\n  utils: {\n    getConversationKey,\n    calcPaddedLen,\n  },\n  encrypt,\n  decrypt,\n}\n", "import type { Event } from './core.ts'\n\nexport const utf8Decoder: TextDecoder = new TextDecoder('utf-8')\nexport const utf8Encoder: TextEncoder = new TextEncoder()\n\nexport function normalizeURL(url: string): string {\n  if (url.indexOf('://') === -1) url = 'wss://' + url\n  let p = new URL(url)\n  p.pathname = p.pathname.replace(/\\/+/g, '/')\n  if (p.pathname.endsWith('/')) p.pathname = p.pathname.slice(0, -1)\n  if ((p.port === '80' && p.protocol === 'ws:') || (p.port === '443' && p.protocol === 'wss:')) p.port = ''\n  p.searchParams.sort()\n  p.hash = ''\n  return p.toString()\n}\n\nexport function insertEventIntoDescendingList(sortedArray: Event[], event: Event): Event[] {\n  const [idx, found] = binarySearch(sortedArray, b => {\n    if (event.id === b.id) return 0\n    if (event.created_at === b.created_at) return -1\n    return b.created_at - event.created_at\n  })\n  if (!found) {\n    sortedArray.splice(idx, 0, event)\n  }\n  return sortedArray\n}\n\nexport function insertEventIntoAscendingList(sortedArray: Event[], event: Event): Event[] {\n  const [idx, found] = binarySearch(sortedArray, b => {\n    if (event.id === b.id) return 0\n    if (event.created_at === b.created_at) return -1\n    return event.created_at - b.created_at\n  })\n  if (!found) {\n    sortedArray.splice(idx, 0, event)\n  }\n  return sortedArray\n}\n\nexport function binarySearch<T>(arr: T[], compare: (b: T) => number): [number, boolean] {\n  let start = 0\n  let end = arr.length - 1\n\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2)\n    const cmp = compare(arr[mid])\n\n    if (cmp === 0) {\n      return [mid, true]\n    }\n\n    if (cmp < 0) {\n      end = mid - 1\n    } else {\n      start = mid + 1\n    }\n  }\n\n  return [start, false]\n}\n\nexport class QueueNode<V> {\n  public value: V\n  public next: QueueNode<V> | null = null\n  public prev: QueueNode<V> | null = null\n\n  constructor(message: V) {\n    this.value = message\n  }\n}\n\nexport class Queue<V> {\n  public first: QueueNode<V> | null\n  public last: QueueNode<V> | null\n\n  constructor() {\n    this.first = null\n    this.last = null\n  }\n\n  enqueue(value: V): boolean {\n    const newNode = new QueueNode(value)\n    if (!this.last) {\n      // list is empty\n      this.first = newNode\n      this.last = newNode\n    } else if (this.last === this.first) {\n      // list has a single element\n      this.last = newNode\n      this.last.prev = this.first\n      this.first.next = newNode\n    } else {\n      // list has elements, add as last\n      newNode.prev = this.last\n      this.last.next = newNode\n      this.last = newNode\n    }\n    return true\n  }\n\n  dequeue(): V | null {\n    if (!this.first) return null\n\n    if (this.first === this.last) {\n      const target = this.first\n      this.first = null\n      this.last = null\n      return target.value\n    }\n\n    const target = this.first\n    this.first = target.next\n\n    return target.value\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_utils", "hkdf_extract", "hkdf_expand"]
}
