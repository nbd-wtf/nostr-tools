{
  "version": 3,
  "sources": ["../../utils.ts", "../../kinds.ts", "../../filter.ts", "../../fakejson.ts", "../../nip42.ts", "../../helpers.ts", "../../abstract-relay.ts"],
  "sourcesContent": ["import type { Event } from './core.ts'\n\nexport const utf8Decoder: TextDecoder = new TextDecoder('utf-8')\nexport const utf8Encoder: TextEncoder = new TextEncoder()\n\nexport function normalizeURL(url: string): string {\n  if (url.indexOf('://') === -1) url = 'wss://' + url\n  let p = new URL(url)\n  p.pathname = p.pathname.replace(/\\/+/g, '/')\n  if (p.pathname.endsWith('/')) p.pathname = p.pathname.slice(0, -1)\n  if ((p.port === '80' && p.protocol === 'ws:') || (p.port === '443' && p.protocol === 'wss:')) p.port = ''\n  p.searchParams.sort()\n  p.hash = ''\n  return p.toString()\n}\n\nexport function insertEventIntoDescendingList(sortedArray: Event[], event: Event): Event[] {\n  const [idx, found] = binarySearch(sortedArray, b => {\n    if (event.id === b.id) return 0\n    if (event.created_at === b.created_at) return -1\n    return b.created_at - event.created_at\n  })\n  if (!found) {\n    sortedArray.splice(idx, 0, event)\n  }\n  return sortedArray\n}\n\nexport function insertEventIntoAscendingList(sortedArray: Event[], event: Event): Event[] {\n  const [idx, found] = binarySearch(sortedArray, b => {\n    if (event.id === b.id) return 0\n    if (event.created_at === b.created_at) return -1\n    return event.created_at - b.created_at\n  })\n  if (!found) {\n    sortedArray.splice(idx, 0, event)\n  }\n  return sortedArray\n}\n\nexport function binarySearch<T>(arr: T[], compare: (b: T) => number): [number, boolean] {\n  let start = 0\n  let end = arr.length - 1\n\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2)\n    const cmp = compare(arr[mid])\n\n    if (cmp === 0) {\n      return [mid, true]\n    }\n\n    if (cmp < 0) {\n      end = mid - 1\n    } else {\n      start = mid + 1\n    }\n  }\n\n  return [start, false]\n}\n\nexport class QueueNode<V> {\n  public value: V\n  public next: QueueNode<V> | null = null\n  public prev: QueueNode<V> | null = null\n\n  constructor(message: V) {\n    this.value = message\n  }\n}\n\nexport class Queue<V> {\n  public first: QueueNode<V> | null\n  public last: QueueNode<V> | null\n\n  constructor() {\n    this.first = null\n    this.last = null\n  }\n\n  enqueue(value: V): boolean {\n    const newNode = new QueueNode(value)\n    if (!this.last) {\n      // list is empty\n      this.first = newNode\n      this.last = newNode\n    } else if (this.last === this.first) {\n      // list has a single element\n      this.last = newNode\n      this.last.prev = this.first\n      this.first.next = newNode\n    } else {\n      // list has elements, add as last\n      newNode.prev = this.last\n      this.last.next = newNode\n      this.last = newNode\n    }\n    return true\n  }\n\n  dequeue(): V | null {\n    if (!this.first) return null\n\n    if (this.first === this.last) {\n      const target = this.first\n      this.first = null\n      this.last = null\n      return target.value\n    }\n\n    const target = this.first\n    this.first = target.next\n\n    return target.value\n  }\n}\n", "import { NostrEvent, validateEvent } from './pure.ts'\n\n/** Events are **regular**, which means they're all expected to be stored by relays. */\nexport function isRegularKind(kind: number): boolean {\n  return (1000 <= kind && kind < 10000) || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind)\n}\n\n/** Events are **replaceable**, which means that, for each combination of `pubkey` and `kind`, only the latest event is expected to (SHOULD) be stored by relays, older versions are expected to be discarded. */\nexport function isReplaceableKind(kind: number): boolean {\n  return [0, 3].includes(kind) || (10000 <= kind && kind < 20000)\n}\n\n/** Events are **ephemeral**, which means they are not expected to be stored by relays. */\nexport function isEphemeralKind(kind: number): boolean {\n  return 20000 <= kind && kind < 30000\n}\n\n/** Events are **parameterized replaceable**, which means that, for each combination of `pubkey`, `kind` and the `d` tag, only the latest event is expected to be stored by relays, older versions are expected to be discarded. */\nexport function isParameterizedReplaceableKind(kind: number): boolean {\n  return 30000 <= kind && kind < 40000\n}\n\n/** Classification of the event kind. */\nexport type KindClassification = 'regular' | 'replaceable' | 'ephemeral' | 'parameterized' | 'unknown'\n\n/** Determine the classification of this kind of event if known, or `unknown`. */\nexport function classifyKind(kind: number): KindClassification {\n  if (isRegularKind(kind)) return 'regular'\n  if (isReplaceableKind(kind)) return 'replaceable'\n  if (isEphemeralKind(kind)) return 'ephemeral'\n  if (isParameterizedReplaceableKind(kind)) return 'parameterized'\n  return 'unknown'\n}\n\nexport function isKind<T extends number>(event: unknown, kind: T | Array<T>): event is NostrEvent & { kind: T } {\n  const kindAsArray: number[] = kind instanceof Array ? kind : [kind]\n  return (validateEvent(event) && kindAsArray.includes(event.kind)) || false\n}\n\nexport const Metadata = 0\nexport type Metadata = typeof Metadata\nexport const ShortTextNote = 1\nexport type ShortTextNote = typeof ShortTextNote\nexport const RecommendRelay = 2\nexport type RecommendRelay = typeof RecommendRelay\nexport const Contacts = 3\nexport type Contacts = typeof Contacts\nexport const EncryptedDirectMessage = 4\nexport type EncryptedDirectMessage = typeof EncryptedDirectMessage\nexport const EventDeletion = 5\nexport type EventDeletion = typeof EventDeletion\nexport const Repost = 6\nexport type Repost = typeof Repost\nexport const Reaction = 7\nexport type Reaction = typeof Reaction\nexport const BadgeAward = 8\nexport type BadgeAward = typeof BadgeAward\nexport const Seal = 13\nexport type Seal = typeof Seal\nexport const PrivateDirectMessage = 14\nexport type PrivateDirectMessage = typeof PrivateDirectMessage\nexport const GenericRepost = 16\nexport type GenericRepost = typeof GenericRepost\nexport const ChannelCreation = 40\nexport type ChannelCreation = typeof ChannelCreation\nexport const ChannelMetadata = 41\nexport type ChannelMetadata = typeof ChannelMetadata\nexport const ChannelMessage = 42\nexport type ChannelMessage = typeof ChannelMessage\nexport const ChannelHideMessage = 43\nexport type ChannelHideMessage = typeof ChannelHideMessage\nexport const ChannelMuteUser = 44\nexport type ChannelMuteUser = typeof ChannelMuteUser\nexport const OpenTimestamps = 1040\nexport type OpenTimestamps = typeof OpenTimestamps\nexport const GiftWrap = 1059\nexport type GiftWrap = typeof GiftWrap\nexport const FileMetadata = 1063\nexport type FileMetadata = typeof FileMetadata\nexport const LiveChatMessage = 1311\nexport type LiveChatMessage = typeof LiveChatMessage\nexport const ProblemTracker = 1971\nexport type ProblemTracker = typeof ProblemTracker\nexport const Report = 1984\nexport type Report = typeof Report\nexport const Reporting = 1984\nexport type Reporting = typeof Reporting\nexport const Label = 1985\nexport type Label = typeof Label\nexport const CommunityPostApproval = 4550\nexport type CommunityPostApproval = typeof CommunityPostApproval\nexport const JobRequest = 5999\nexport type JobRequest = typeof JobRequest\nexport const JobResult = 6999\nexport type JobResult = typeof JobResult\nexport const JobFeedback = 7000\nexport type JobFeedback = typeof JobFeedback\nexport const ZapGoal = 9041\nexport type ZapGoal = typeof ZapGoal\nexport const ZapRequest = 9734\nexport type ZapRequest = typeof ZapRequest\nexport const Zap = 9735\nexport type Zap = typeof Zap\nexport const Highlights = 9802\nexport type Highlights = typeof Highlights\nexport const Mutelist = 10000\nexport type Mutelist = typeof Mutelist\nexport const Pinlist = 10001\nexport type Pinlist = typeof Pinlist\nexport const RelayList = 10002\nexport type RelayList = typeof RelayList\nexport const BookmarkList = 10003\nexport type BookmarkList = typeof BookmarkList\nexport const CommunitiesList = 10004\nexport type CommunitiesList = typeof CommunitiesList\nexport const PublicChatsList = 10005\nexport type PublicChatsList = typeof PublicChatsList\nexport const BlockedRelaysList = 10006\nexport type BlockedRelaysList = typeof BlockedRelaysList\nexport const SearchRelaysList = 10007\nexport type SearchRelaysList = typeof SearchRelaysList\nexport const InterestsList = 10015\nexport type InterestsList = typeof InterestsList\nexport const UserEmojiList = 10030\nexport type UserEmojiList = typeof UserEmojiList\nexport const DirectMessageRelaysList = 10050\nexport type DirectMessageRelaysList = typeof DirectMessageRelaysList\nexport const FileServerPreference = 10096\nexport type FileServerPreference = typeof FileServerPreference\nexport const NWCWalletInfo = 13194\nexport type NWCWalletInfo = typeof NWCWalletInfo\nexport const LightningPubRPC = 21000\nexport type LightningPubRPC = typeof LightningPubRPC\nexport const ClientAuth = 22242\nexport type ClientAuth = typeof ClientAuth\nexport const NWCWalletRequest = 23194\nexport type NWCWalletRequest = typeof NWCWalletRequest\nexport const NWCWalletResponse = 23195\nexport type NWCWalletResponse = typeof NWCWalletResponse\nexport const NostrConnect = 24133\nexport type NostrConnect = typeof NostrConnect\nexport const HTTPAuth = 27235\nexport type HTTPAuth = typeof HTTPAuth\nexport const Followsets = 30000\nexport type Followsets = typeof Followsets\nexport const Genericlists = 30001\nexport type Genericlists = typeof Genericlists\nexport const Relaysets = 30002\nexport type Relaysets = typeof Relaysets\nexport const Bookmarksets = 30003\nexport type Bookmarksets = typeof Bookmarksets\nexport const Curationsets = 30004\nexport type Curationsets = typeof Curationsets\nexport const ProfileBadges = 30008\nexport type ProfileBadges = typeof ProfileBadges\nexport const BadgeDefinition = 30009\nexport type BadgeDefinition = typeof BadgeDefinition\nexport const Interestsets = 30015\nexport type Interestsets = typeof Interestsets\nexport const CreateOrUpdateStall = 30017\nexport type CreateOrUpdateStall = typeof CreateOrUpdateStall\nexport const CreateOrUpdateProduct = 30018\nexport type CreateOrUpdateProduct = typeof CreateOrUpdateProduct\nexport const LongFormArticle = 30023\nexport type LongFormArticle = typeof LongFormArticle\nexport const DraftLong = 30024\nexport type DraftLong = typeof DraftLong\nexport const Emojisets = 30030\nexport type Emojisets = typeof Emojisets\nexport const Application = 30078\nexport type Application = typeof Application\nexport const LiveEvent = 30311\nexport type LiveEvent = typeof LiveEvent\nexport const UserStatuses = 30315\nexport type UserStatuses = typeof UserStatuses\nexport const ClassifiedListing = 30402\nexport type ClassifiedListing = typeof ClassifiedListing\nexport const DraftClassifiedListing = 30403\nexport type DraftClassifiedListing = typeof DraftClassifiedListing\nexport const Date = 31922\nexport type Date = typeof Date\nexport const Time = 31923\nexport type Time = typeof Time\nexport const Calendar = 31924\nexport type Calendar = typeof Calendar\nexport const CalendarEventRSVP = 31925\nexport type CalendarEventRSVP = typeof CalendarEventRSVP\nexport const Handlerrecommendation = 31989\nexport type Handlerrecommendation = typeof Handlerrecommendation\nexport const Handlerinformation = 31990\nexport type Handlerinformation = typeof Handlerinformation\nexport const CommunityDefinition = 34550\nexport type CommunityDefinition = typeof CommunityDefinition\n", "import { Event } from './core.ts'\nimport { isParameterizedReplaceableKind, isReplaceableKind } from './kinds.ts'\n\nexport type Filter = {\n  ids?: string[]\n  kinds?: number[]\n  authors?: string[]\n  since?: number\n  until?: number\n  limit?: number\n  search?: string\n  [key: `#${string}`]: string[] | undefined\n}\n\nexport function matchFilter(filter: Filter, event: Event): boolean {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false\n  }\n\n  for (let f in filter) {\n    if (f[0] === '#') {\n      let tagName = f.slice(1)\n      let values = filter[`#${tagName}`]\n      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values!.indexOf(v) !== -1)) return false\n    }\n  }\n\n  if (filter.since && event.created_at < filter.since) return false\n  if (filter.until && event.created_at > filter.until) return false\n\n  return true\n}\n\nexport function matchFilters(filters: Filter[], event: Event): boolean {\n  for (let i = 0; i < filters.length; i++) {\n    if (matchFilter(filters[i], event)) {\n      return true\n    }\n  }\n  return false\n}\n\nexport function mergeFilters(...filters: Filter[]): Filter {\n  let result: Filter = {}\n  for (let i = 0; i < filters.length; i++) {\n    let filter = filters[i]\n    Object.entries(filter).forEach(([property, values]) => {\n      if (property === 'kinds' || property === 'ids' || property === 'authors' || property[0] === '#') {\n        // @ts-ignore\n        result[property] = result[property] || []\n        // @ts-ignore\n        for (let v = 0; v < values.length; v++) {\n          // @ts-ignore\n          let value = values[v]\n          // @ts-ignore\n          if (!result[property].includes(value)) result[property].push(value)\n        }\n      }\n    })\n\n    if (filter.limit && (!result.limit || filter.limit > result.limit)) result.limit = filter.limit\n    if (filter.until && (!result.until || filter.until > result.until)) result.until = filter.until\n    if (filter.since && (!result.since || filter.since < result.since)) result.since = filter.since\n  }\n\n  return result\n}\n\n/**\n * Calculate the intrinsic limit of a filter.\n * This function returns a positive integer, or `Infinity` if there is no intrinsic limit.\n */\nexport function getFilterLimit(filter: Filter): number {\n  if (filter.ids && !filter.ids.length) return 0\n  if (filter.kinds && !filter.kinds.length) return 0\n  if (filter.authors && !filter.authors.length) return 0\n\n  for (const [key, value] of Object.entries(filter)) {\n    if (key[0] === '#' && Array.isArray(value) && !value.length) return 0\n  }\n\n  return Math.min(\n    // The `limit` property creates an artificial limit.\n    Math.max(0, filter.limit ?? Infinity),\n\n    // There can only be one event per `id`.\n    filter.ids?.length ?? Infinity,\n\n    // Replaceable events are limited by the number of authors and kinds.\n    filter.authors?.length && filter.kinds?.every(kind => isReplaceableKind(kind))\n      ? filter.authors.length * filter.kinds.length\n      : Infinity,\n\n    // Parameterized replaceable events are limited by the number of authors, kinds, and \"d\" tags.\n    filter.authors?.length && filter.kinds?.every(kind => isParameterizedReplaceableKind(kind)) && filter['#d']?.length\n      ? filter.authors.length * filter.kinds.length * filter['#d'].length\n      : Infinity,\n  )\n}\n", "export function getHex64(json: string, field: string): string {\n  let len = field.length + 3\n  let idx = json.indexOf(`\"${field}\":`) + len\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1\n  return json.slice(s, s + 64)\n}\n\nexport function getInt(json: string, field: string): number {\n  let len = field.length\n  let idx = json.indexOf(`\"${field}\":`) + len + 3\n  let sliced = json.slice(idx)\n  let end = Math.min(sliced.indexOf(','), sliced.indexOf('}'))\n  return parseInt(sliced.slice(0, end), 10)\n}\n\nexport function getSubscriptionId(json: string): string | null {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`)\n  if (idx === -1) return null\n\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`)\n  if (pstart === -1) return null\n  let start = idx + 7 + 1 + pstart\n\n  let pend = json.slice(start + 1, 80).indexOf(`\"`)\n  if (pend === -1) return null\n  let end = start + 1 + pend\n\n  return json.slice(start + 1, end)\n}\n\nexport function matchEventId(json: string, id: string): boolean {\n  return id === getHex64(json, 'id')\n}\n\nexport function matchEventPubkey(json: string, pubkey: string): boolean {\n  return pubkey === getHex64(json, 'pubkey')\n}\n\nexport function matchEventKind(json: string, kind: number): boolean {\n  return kind === getInt(json, 'kind')\n}\n", "import { EventTemplate } from './core.ts'\nimport { ClientAuth } from './kinds.ts'\n\n/**\n * creates an EventTemplate for an AUTH event to be signed.\n */\nexport function makeAuthEvent(relayURL: string, challenge: string): EventTemplate {\n  return {\n    kind: ClientAuth,\n    created_at: Math.floor(Date.now() / 1000),\n    tags: [\n      ['relay', relayURL],\n      ['challenge', challenge],\n    ],\n    content: '',\n  }\n}\n", "import { verifiedSymbol, type Event, type Nostr, VerifiedEvent } from './core.ts'\n\nexport async function yieldThread() {\n  return new Promise<void>(resolve => {\n    const ch = new MessageChannel()\n    const handler = () => {\n      // @ts-ignore (typescript thinks this property should be called `removeListener`, but in fact it's `removeEventListener`)\n      ch.port1.removeEventListener('message', handler)\n      resolve()\n    }\n    // @ts-ignore (typescript thinks this property should be called `addListener`, but in fact it's `addEventListener`)\n    ch.port1.addEventListener('message', handler)\n    ch.port2.postMessage(0)\n    ch.port1.start()\n  })\n}\n\nexport const alwaysTrue: Nostr['verifyEvent'] = (t: Event): t is VerifiedEvent => {\n  t[verifiedSymbol] = true\n  return true\n}\n", "/* global WebSocket */\n\nimport type { Event, EventTemplate, VerifiedEvent, Nostr } from './core.ts'\nimport { matchFilters, type Filter } from './filter.ts'\nimport { getHex64, getSubscriptionId } from './fakejson.ts'\nimport { Queue, normalizeURL } from './utils.ts'\nimport { makeAuthEvent } from './nip42.ts'\nimport { yieldThread } from './helpers.ts'\n\nexport type AbstractRelayConstructorOptions = {\n  verifyEvent: Nostr['verifyEvent']\n  websocketImplementation?: typeof WebSocket\n}\n\nexport class AbstractRelay {\n  public readonly url: string\n  private _connected: boolean = false\n\n  public onclose: (() => void) | null = null\n  public onnotice: (msg: string) => void = msg => console.debug(`NOTICE from ${this.url}: ${msg}`)\n\n  // this is exposed just to help in ndk migration, shouldn't be relied upon\n  public _onauth: ((challenge: string) => void) | null = null\n\n  public baseEoseTimeout: number = 4400\n  public connectionTimeout: number = 4400\n  public publishTimeout: number = 4400\n  public openSubs: Map<string, Subscription> = new Map()\n  private connectionTimeoutHandle: ReturnType<typeof setTimeout> | undefined\n\n  private connectionPromise: Promise<void> | undefined\n  private openCountRequests = new Map<string, CountResolver>()\n  private openEventPublishes = new Map<string, EventPublishResolver>()\n  private ws: WebSocket | undefined\n  private incomingMessageQueue = new Queue<string>()\n  private queueRunning = false\n  private challenge: string | undefined\n  private serial: number = 0\n  private verifyEvent: Nostr['verifyEvent']\n\n  private _WebSocket: typeof WebSocket\n\n  constructor(url: string, opts: AbstractRelayConstructorOptions) {\n    this.url = normalizeURL(url)\n    this.verifyEvent = opts.verifyEvent\n    this._WebSocket = opts.websocketImplementation || WebSocket\n  }\n\n  static async connect(url: string, opts: AbstractRelayConstructorOptions): Promise<AbstractRelay> {\n    const relay = new AbstractRelay(url, opts)\n    await relay.connect()\n    return relay\n  }\n\n  private closeAllSubscriptions(reason: string) {\n    for (let [_, sub] of this.openSubs) {\n      sub.close(reason)\n    }\n    this.openSubs.clear()\n\n    for (let [_, ep] of this.openEventPublishes) {\n      ep.reject(new Error(reason))\n    }\n    this.openEventPublishes.clear()\n\n    for (let [_, cr] of this.openCountRequests) {\n      cr.reject(new Error(reason))\n    }\n    this.openCountRequests.clear()\n  }\n\n  public get connected(): boolean {\n    return this._connected\n  }\n\n  public async connect(): Promise<void> {\n    if (this.connectionPromise) return this.connectionPromise\n\n    this.challenge = undefined\n    this.connectionPromise = new Promise((resolve, reject) => {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        reject('connection timed out')\n        this.connectionPromise = undefined\n        this.onclose?.()\n        this.closeAllSubscriptions('relay connection timed out')\n      }, this.connectionTimeout)\n\n      try {\n        this.ws = new this._WebSocket(this.url)\n      } catch (err) {\n        reject(err)\n        return\n      }\n\n      this.ws.onopen = () => {\n        clearTimeout(this.connectionTimeoutHandle)\n        this._connected = true\n        resolve()\n      }\n\n      this.ws.onerror = ev => {\n        reject((ev as any).message || 'websocket error')\n        if (this._connected) {\n          this._connected = false\n          this.connectionPromise = undefined\n          this.onclose?.()\n          this.closeAllSubscriptions('relay connection errored')\n        }\n      }\n\n      this.ws.onclose = async () => {\n        if (this._connected) {\n          this._connected = false\n          this.connectionPromise = undefined\n          this.onclose?.()\n          this.closeAllSubscriptions('relay connection closed')\n        }\n      }\n\n      this.ws.onmessage = this._onmessage.bind(this)\n    })\n\n    return this.connectionPromise\n  }\n\n  private async runQueue() {\n    this.queueRunning = true\n    while (true) {\n      if (false === this.handleNext()) {\n        break\n      }\n      await yieldThread()\n    }\n    this.queueRunning = false\n  }\n\n  private handleNext(): undefined | false {\n    const json = this.incomingMessageQueue.dequeue()\n    if (!json) {\n      return false\n    }\n\n    const subid = getSubscriptionId(json)\n    if (subid) {\n      const so = this.openSubs.get(subid as string)\n      if (!so) {\n        // this is an EVENT message, but for a subscription we don't have, so just stop here\n        return\n      }\n\n      // this will be called only when this message is a EVENT message for a subscription we have\n      // we do this before parsing the JSON to not have to do that for duplicate events\n      //   since JSON parsing is slow\n      const id = getHex64(json, 'id')\n      const alreadyHave = so.alreadyHaveEvent?.(id)\n\n      // notify any interested client that the relay has this event\n      // (do this after alreadyHaveEvent() because the client may rely on this to answer that)\n      so.receivedEvent?.(this, id)\n\n      if (alreadyHave) {\n        // if we had already seen this event we can just stop here\n        return\n      }\n    }\n\n    try {\n      let data = JSON.parse(json)\n      // we won't do any checks against the data since all failures (i.e. invalid messages from relays)\n      // will naturally be caught by the encompassing try..catch block\n\n      switch (data[0]) {\n        case 'EVENT': {\n          const so = this.openSubs.get(data[1] as string) as Subscription\n          const event = data[2] as Event\n          if (this.verifyEvent(event) && matchFilters(so.filters, event)) {\n            so.onevent(event)\n          }\n          return\n        }\n        case 'COUNT': {\n          const id: string = data[1]\n          const payload = data[2] as { count: number }\n          const cr = this.openCountRequests.get(id) as CountResolver\n          if (cr) {\n            cr.resolve(payload.count)\n            this.openCountRequests.delete(id)\n          }\n          return\n        }\n        case 'EOSE': {\n          const so = this.openSubs.get(data[1] as string)\n          if (!so) return\n          so.receivedEose()\n          return\n        }\n        case 'OK': {\n          const id: string = data[1]\n          const ok: boolean = data[2]\n          const reason: string = data[3]\n          const ep = this.openEventPublishes.get(id) as EventPublishResolver\n          if (ep) {\n            if (ok) ep.resolve(reason)\n            else ep.reject(new Error(reason))\n            this.openEventPublishes.delete(id)\n          }\n          return\n        }\n        case 'CLOSED': {\n          const id: string = data[1]\n          const so = this.openSubs.get(id)\n          if (!so) return\n          so.closed = true\n          so.close(data[2] as string)\n          return\n        }\n        case 'NOTICE':\n          this.onnotice(data[1] as string)\n          return\n        case 'AUTH': {\n          this.challenge = data[1] as string\n          this._onauth?.(data[1] as string)\n          return\n        }\n      }\n    } catch (err) {\n      return\n    }\n  }\n\n  public async send(message: string) {\n    if (!this.connectionPromise) throw new Error('sending on closed connection')\n\n    this.connectionPromise.then(() => {\n      this.ws?.send(message)\n    })\n  }\n\n  public async auth(signAuthEvent: (evt: EventTemplate) => Promise<VerifiedEvent>): Promise<string> {\n    if (!this.challenge) throw new Error(\"can't perform auth, no challenge was received\")\n    const evt = await signAuthEvent(makeAuthEvent(this.url, this.challenge))\n    const ret = new Promise<string>((resolve, reject) => {\n      this.openEventPublishes.set(evt.id, { resolve, reject })\n    })\n    this.send('[\"AUTH\",' + JSON.stringify(evt) + ']')\n    return ret\n  }\n\n  public async publish(event: Event): Promise<string> {\n    const ret = new Promise<string>((resolve, reject) => {\n      this.openEventPublishes.set(event.id, { resolve, reject })\n    })\n    this.send('[\"EVENT\",' + JSON.stringify(event) + ']')\n    setTimeout(() => {\n      const ep = this.openEventPublishes.get(event.id) as EventPublishResolver\n      if (ep) {\n        ep.reject(new Error('publish timed out'))\n        this.openEventPublishes.delete(event.id)\n      }\n    }, this.publishTimeout)\n    return ret\n  }\n\n  public async count(filters: Filter[], params: { id?: string | null }): Promise<number> {\n    this.serial++\n    const id = params?.id || 'count:' + this.serial\n    const ret = new Promise<number>((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject })\n    })\n    this.send('[\"COUNT\",\"' + id + '\",' + JSON.stringify(filters).substring(1))\n    return ret\n  }\n\n  public subscribe(filters: Filter[], params: Partial<SubscriptionParams> & { id?: string }): Subscription {\n    const subscription = this.prepareSubscription(filters, params)\n    subscription.fire()\n    return subscription\n  }\n\n  public prepareSubscription(filters: Filter[], params: Partial<SubscriptionParams> & { id?: string }): Subscription {\n    this.serial++\n    const id = params.id || 'sub:' + this.serial\n    const subscription = new Subscription(this, id, filters, params)\n    this.openSubs.set(id, subscription)\n    return subscription\n  }\n\n  public close() {\n    this.closeAllSubscriptions('relay connection closed by us')\n    this._connected = false\n    this.ws?.close()\n  }\n\n  // this is the function assigned to this.ws.onmessage\n  // it's exposed for testing and debugging purposes\n  public _onmessage(ev: MessageEvent<any>) {\n    this.incomingMessageQueue.enqueue(ev.data as string)\n    if (!this.queueRunning) {\n      this.runQueue()\n    }\n  }\n}\n\nexport class Subscription {\n  public readonly relay: AbstractRelay\n  public readonly id: string\n\n  public closed: boolean = false\n  public eosed: boolean = false\n  public filters: Filter[]\n  public alreadyHaveEvent: ((id: string) => boolean) | undefined\n  public receivedEvent: ((relay: AbstractRelay, id: string) => void) | undefined\n\n  public onevent: (evt: Event) => void\n  public oneose: (() => void) | undefined\n  public onclose: ((reason: string) => void) | undefined\n\n  public eoseTimeout: number\n  private eoseTimeoutHandle: ReturnType<typeof setTimeout> | undefined\n\n  constructor(relay: AbstractRelay, id: string, filters: Filter[], params: SubscriptionParams) {\n    this.relay = relay\n    this.filters = filters\n    this.id = id\n    this.alreadyHaveEvent = params.alreadyHaveEvent\n    this.receivedEvent = params.receivedEvent\n    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout\n\n    this.oneose = params.oneose\n    this.onclose = params.onclose\n    this.onevent =\n      params.onevent ||\n      (event => {\n        console.warn(\n          `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,\n          event,\n        )\n      })\n  }\n\n  public fire() {\n    this.relay.send('[\"REQ\",\"' + this.id + '\",' + JSON.stringify(this.filters).substring(1))\n\n    // only now we start counting the eoseTimeout\n    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout)\n  }\n\n  public receivedEose() {\n    if (this.eosed) return\n    clearTimeout(this.eoseTimeoutHandle)\n    this.eosed = true\n    this.oneose?.()\n  }\n\n  public close(reason: string = 'closed by caller') {\n    if (!this.closed && this.relay.connected) {\n      // if the connection was closed by the user calling .close() we will send a CLOSE message\n      // otherwise this._open will be already set to false so we will skip this\n      this.relay.send('[\"CLOSE\",' + JSON.stringify(this.id) + ']')\n      this.closed = true\n    }\n    this.relay.openSubs.delete(this.id)\n    this.onclose?.(reason)\n  }\n}\n\nexport type SubscriptionParams = {\n  onevent?: (evt: Event) => void\n  oneose?: () => void\n  onclose?: (reason: string) => void\n  alreadyHaveEvent?: (id: string) => boolean\n  receivedEvent?: (relay: AbstractRelay, id: string) => void\n  eoseTimeout?: number\n}\n\nexport type CountResolver = {\n  resolve: (count: number) => void\n  reject: (err: Error) => void\n}\n\nexport type EventPublishResolver = {\n  resolve: (reason: string) => void\n  reject: (err: Error) => void\n}\n"],
  "mappings": "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",
  "names": ["target"]
}
