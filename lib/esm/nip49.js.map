{
  "version": 3,
  "sources": ["../../nip49.ts", "../../nip19.ts"],
  "sourcesContent": ["import { scrypt } from '@noble/hashes/scrypt'\nimport { xchacha20poly1305 } from '@noble/ciphers/chacha'\nimport { concatBytes, randomBytes } from '@noble/hashes/utils'\nimport { Bech32MaxSize, Ncryptsec, encodeBytes } from './nip19.ts'\nimport { bech32 } from '@scure/base'\n\nexport function encrypt(\n  sec: Uint8Array,\n  password: string,\n  logn: number = 16,\n  ksb: 0x00 | 0x01 | 0x02 = 0x02,\n): Ncryptsec {\n  let salt = randomBytes(16)\n  let n = 2 ** logn\n  let key = scrypt(password.normalize('NFKC'), salt, { N: n, r: 8, p: 1, dkLen: 32 })\n  let nonce = randomBytes(24)\n  let aad = Uint8Array.from([ksb])\n  let xc2p1 = xchacha20poly1305(key, nonce, aad)\n  let ciphertext = xc2p1.encrypt(sec)\n  let b = concatBytes(Uint8Array.from([0x02]), Uint8Array.from([logn]), salt, nonce, aad, ciphertext)\n  return encodeBytes('ncryptsec', b)\n}\n\nexport function decrypt(ncryptsec: string, password: string): Uint8Array {\n  let { prefix, words } = bech32.decode(ncryptsec, Bech32MaxSize)\n  if (prefix !== 'ncryptsec') {\n    throw new Error(`invalid prefix ${prefix}, expected 'ncryptsec'`)\n  }\n  let b = new Uint8Array(bech32.fromWords(words))\n\n  let version = b[0]\n  if (version !== 0x02) {\n    throw new Error(`invalid version ${version}, expected 0x02`)\n  }\n\n  let logn = b[1]\n  let n = 2 ** logn\n\n  let salt = b.slice(2, 2 + 16)\n  let nonce = b.slice(2 + 16, 2 + 16 + 24)\n  let ksb = b[2 + 16 + 24]\n  let aad = Uint8Array.from([ksb])\n  let ciphertext = b.slice(2 + 16 + 24 + 1)\n\n  let key = scrypt(password.normalize('NFKC'), salt, { N: n, r: 8, p: 1, dkLen: 32 })\n  let xc2p1 = xchacha20poly1305(key, nonce, aad)\n  let sec = xc2p1.decrypt(ciphertext)\n\n  return sec\n}\n", "import { bytesToHex, concatBytes, hexToBytes } from '@noble/hashes/utils'\nimport { bech32 } from '@scure/base'\n\nimport { utf8Decoder, utf8Encoder } from './utils.ts'\n\nexport type NProfile = `nprofile1${string}`\nexport type NRelay = `nrelay1${string}`\nexport type NEvent = `nevent1${string}`\nexport type NAddr = `naddr1${string}`\nexport type NSec = `nsec1${string}`\nexport type NPub = `npub1${string}`\nexport type Note = `note1${string}`\nexport type Ncryptsec = `ncryptsec1${string}`\nexport type Noffer = `noffer1${string}`\nexport type Ndebit = `ndebit1${string}`\n\nexport const NostrTypeGuard = {\n  isNProfile: (value?: string | null): value is NProfile => /^nprofile1[a-z\\d]+$/.test(value || ''),\n  isNRelay: (value?: string | null): value is NRelay => /^nrelay1[a-z\\d]+$/.test(value || ''),\n  isNEvent: (value?: string | null): value is NEvent => /^nevent1[a-z\\d]+$/.test(value || ''),\n  isNAddr: (value?: string | null): value is NAddr => /^naddr1[a-z\\d]+$/.test(value || ''),\n  isNSec: (value?: string | null): value is NSec => /^nsec1[a-z\\d]{58}$/.test(value || ''),\n  isNPub: (value?: string | null): value is NPub => /^npub1[a-z\\d]{58}$/.test(value || ''),\n  isNote: (value?: string | null): value is Note => /^note1[a-z\\d]+$/.test(value || ''),\n  isNcryptsec: (value?: string | null): value is Ncryptsec => /^ncryptsec1[a-z\\d]+$/.test(value || ''),\n  isNoffer: (value?: string | null): value is Noffer => /^noffer1[a-z\\d]+$/.test(value || ''),\n  isNdebit: (value?: string | null): value is Ndebit => /^ndebit1[a-z\\d]+$/.test(value || ''),\n}\n\nexport const Bech32MaxSize = 5000\n\n/**\n * Bech32 regex.\n * @see https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32\n */\nexport const BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/\n\nfunction integerToUint8Array(number: number) {\n  // Create a Uint8Array with enough space to hold a 32-bit integer (4 bytes).\n  const uint8Array = new Uint8Array(4)\n\n  // Use bitwise operations to extract the bytes.\n  uint8Array[0] = (number >> 24) & 0xff // Most significant byte (MSB)\n  uint8Array[1] = (number >> 16) & 0xff\n  uint8Array[2] = (number >> 8) & 0xff\n  uint8Array[3] = number & 0xff // Least significant byte (LSB)\n\n  return uint8Array\n}\n\nexport type ProfilePointer = {\n  pubkey: string // hex\n  relays?: string[]\n}\n\nexport type EventPointer = {\n  id: string // hex\n  relays?: string[]\n  author?: string\n  kind?: number\n}\n\nexport type AddressPointer = {\n  identifier: string\n  pubkey: string\n  kind: number\n  relays?: string[]\n}\n\nexport type OfferPointer = {\n  pubkey: string,\n  relay: string,\n  offer: string\n  priceType: OfferPriceType,\n  price?: number\n}\nexport enum OfferPriceType {\n  Fixed = 0,\n  Variable = 1,\n  Spontaneous = 2,\n}\n\nexport type DebitPointer = {\n  pubkey: string,\n  relay: string,\n  pointer?: string,\n}\n\ntype Prefixes = {\n  nprofile: ProfilePointer\n  nevent: EventPointer\n  naddr: AddressPointer\n  nsec: Uint8Array\n  npub: string\n  note: string\n  noffer: OfferPointer\n  ndebit: DebitPointer\n}\n\ntype DecodeValue<Prefix extends keyof Prefixes> = {\n  type: Prefix\n  data: Prefixes[Prefix]\n}\n\nexport type DecodeResult = {\n  [P in keyof Prefixes]: DecodeValue<P>\n}[keyof Prefixes]\n\nexport function decode<Prefix extends keyof Prefixes>(nip19: `${Prefix}1${string}`): DecodeValue<Prefix>\nexport function decode(nip19: string): DecodeResult\nexport function decode(nip19: string): DecodeResult {\n  let { prefix, words } = bech32.decode(nip19, Bech32MaxSize)\n  let data = new Uint8Array(bech32.fromWords(words))\n\n  switch (prefix) {\n    case 'nprofile': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nprofile')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n\n      return {\n        type: 'nprofile',\n        data: {\n          pubkey: bytesToHex(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n        },\n      }\n    }\n    case 'nevent': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nevent')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n      if (tlv[2] && tlv[2][0].length !== 32) throw new Error('TLV 2 should be 32 bytes')\n      if (tlv[3] && tlv[3][0].length !== 4) throw new Error('TLV 3 should be 4 bytes')\n\n      return {\n        type: 'nevent',\n        data: {\n          id: bytesToHex(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0] ? bytesToHex(tlv[2][0]) : undefined,\n          kind: tlv[3]?.[0] ? parseInt(bytesToHex(tlv[3][0]), 16) : undefined,\n        },\n      }\n    }\n\n    case 'naddr': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for naddr')\n      if (!tlv[2]?.[0]) throw new Error('missing TLV 2 for naddr')\n      if (tlv[2][0].length !== 32) throw new Error('TLV 2 should be 32 bytes')\n      if (!tlv[3]?.[0]) throw new Error('missing TLV 3 for naddr')\n      if (tlv[3][0].length !== 4) throw new Error('TLV 3 should be 4 bytes')\n\n      return {\n        type: 'naddr',\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: bytesToHex(tlv[2][0]),\n          kind: parseInt(bytesToHex(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n        },\n      }\n    }\n\n    case 'nsec':\n      return { type: prefix, data }\n\n    case 'npub':\n    case 'note':\n      return { type: prefix, data: bytesToHex(data) }\n    case 'noffer': {\n      const tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for noffer')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n      if (!tlv[1]?.[0]) throw new Error('missing TLV 1 for noffer')\n      if (!tlv[2]?.[0]) throw new Error('missing TLV 2 for noffer')\n      if (!tlv[3]?.[0]) throw new Error('missing TLV 3 for noffer')\n      return {\n        type: 'noffer',\n        data: {\n          pubkey: bytesToHex(tlv[0][0]),\n          relay: utf8Decoder.decode(tlv[1][0]),\n          offer: utf8Decoder.decode(tlv[2][0]),\n          priceType: tlv[3][0][0],\n          price: tlv[4] ? parseInt(bytesToHex(tlv[4][0]), 16) : undefined\n        }\n      }\n    }\n    case 'ndebit': {\n      const tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for ndebit')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n      if (!tlv[1]?.[0]) throw new Error('missing TLV 1 for ndebit')\n      return {\n        type: 'ndebit',\n        data: {\n          pubkey: bytesToHex(tlv[0][0]),\n          relay: utf8Decoder.decode(tlv[1][0]),\n          pointer: tlv[2] ? utf8Decoder.decode(tlv[2][0]) : undefined\n        }\n      }\n    }\n    default:\n      throw new Error(`unknown prefix ${prefix}`)\n  }\n}\n\ntype TLV = { [t: number]: Uint8Array[] }\n\nfunction parseTLV(data: Uint8Array): TLV {\n  let result: TLV = {}\n  let rest = data\n  while (rest.length > 0) {\n    let t = rest[0]\n    let l = rest[1]\n    let v = rest.slice(2, 2 + l)\n    rest = rest.slice(2 + l)\n    if (v.length < l) throw new Error(`not enough data to read on TLV ${t}`)\n    result[t] = result[t] || []\n    result[t].push(v)\n  }\n  return result\n}\n\nexport function nsecEncode(key: Uint8Array): NSec {\n  return encodeBytes('nsec', key)\n}\n\nexport function npubEncode(hex: string): NPub {\n  return encodeBytes('npub', hexToBytes(hex))\n}\n\nexport function noteEncode(hex: string): Note {\n  return encodeBytes('note', hexToBytes(hex))\n}\n\nfunction encodeBech32<Prefix extends string>(prefix: Prefix, data: Uint8Array): `${Prefix}1${string}` {\n  let words = bech32.toWords(data)\n  return bech32.encode(prefix, words, Bech32MaxSize) as `${Prefix}1${string}`\n}\n\nexport function encodeBytes<Prefix extends string>(prefix: Prefix, bytes: Uint8Array): `${Prefix}1${string}` {\n  return encodeBech32(prefix, bytes)\n}\n\nexport function nprofileEncode(profile: ProfilePointer): NProfile {\n  let data = encodeTLV({\n    0: [hexToBytes(profile.pubkey)],\n    1: (profile.relays || []).map(url => utf8Encoder.encode(url)),\n  })\n  return encodeBech32('nprofile', data)\n}\n\nexport function neventEncode(event: EventPointer): NEvent {\n  let kindArray\n  if (event.kind !== undefined) {\n    kindArray = integerToUint8Array(event.kind)\n  }\n\n  let data = encodeTLV({\n    0: [hexToBytes(event.id)],\n    1: (event.relays || []).map(url => utf8Encoder.encode(url)),\n    2: event.author ? [hexToBytes(event.author)] : [],\n    3: kindArray ? [new Uint8Array(kindArray)] : [],\n  })\n\n  return encodeBech32('nevent', data)\n}\n\nexport function naddrEncode(addr: AddressPointer): NAddr {\n  let kind = new ArrayBuffer(4)\n  new DataView(kind).setUint32(0, addr.kind, false)\n\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map(url => utf8Encoder.encode(url)),\n    2: [hexToBytes(addr.pubkey)],\n    3: [new Uint8Array(kind)],\n  })\n  return encodeBech32('naddr', data)\n}\n\nexport const nofferEncode = (offer: OfferPointer): string => {\n  const o: TLV = {\n    0: [hexToBytes(offer.pubkey)],\n    1: [utf8Encoder.encode(offer.relay)],\n    2: [utf8Encoder.encode(offer.offer)],\n    3: [new Uint8Array([Number(offer.priceType)])],\n  }\n  if (offer.price) {\n    o[4] = [integerToUint8Array(offer.price)]\n  }\n  const data = encodeTLV(o)\n  const words = bech32.toWords(data)\n  return bech32.encode('noffer', words, 5000)\n}\n\nexport const ndebitEncode = (debit: DebitPointer): string => {\n  const o: TLV = {\n    0: [hexToBytes(debit.pubkey)],\n    1: [utf8Encoder.encode(debit.relay)],\n  }\n  if (debit.pointer) {\n    o[2] = [utf8Encoder.encode(debit.pointer)]\n  }\n  const data = encodeTLV(o)\n  const words = bech32.toWords(data)\n  return bech32.encode('ndebit', words, 5000)\n}\n\nfunction encodeTLV(tlv: TLV): Uint8Array {\n  let entries: Uint8Array[] = []\n\n  Object.entries(tlv)\n    .reverse()\n    .forEach(([t, vs]) => {\n      vs.forEach(v => {\n        let entry = new Uint8Array(v.length + 2)\n        entry.set([parseInt(t)], 0)\n        entry.set([v.length], 1)\n        entry.set(v, 2)\n        entries.push(entry)\n      })\n    })\n\n  return concatBytes(...entries)\n}\n"],
  "mappings": ";AAAA,SAAS,cAAc;AACvB,SAAS,yBAAyB;AAClC,SAAS,eAAAA,cAAa,mBAAmB;;;ACFzC,SAAS,YAAY,aAAa,kBAAkB;AACpD,SAAS,cAAc;AA4BhB,IAAM,gBAAgB;AAgN7B,SAAS,aAAoC,QAAgB,MAAyC;AACpG,MAAI,QAAQ,OAAO,QAAQ,IAAI;AAC/B,SAAO,OAAO,OAAO,QAAQ,OAAO,aAAa;AACnD;AAEO,SAAS,YAAmC,QAAgB,OAA0C;AAC3G,SAAO,aAAa,QAAQ,KAAK;AACnC;;;ADhPA,SAAS,UAAAC,eAAc;AAEhB,SAAS,QACd,KACA,UACA,OAAe,IACf,MAA0B,GACf;AACX,MAAI,OAAO,YAAY,EAAE;AACzB,MAAI,IAAI,KAAK;AACb,MAAI,MAAM,OAAO,SAAS,UAAU,MAAM,GAAG,MAAM,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,OAAO,GAAG,CAAC;AAClF,MAAI,QAAQ,YAAY,EAAE;AAC1B,MAAI,MAAM,WAAW,KAAK,CAAC,GAAG,CAAC;AAC/B,MAAI,QAAQ,kBAAkB,KAAK,OAAO,GAAG;AAC7C,MAAI,aAAa,MAAM,QAAQ,GAAG;AAClC,MAAI,IAAIC,aAAY,WAAW,KAAK,CAAC,CAAI,CAAC,GAAG,WAAW,KAAK,CAAC,IAAI,CAAC,GAAG,MAAM,OAAO,KAAK,UAAU;AAClG,SAAO,YAAY,aAAa,CAAC;AACnC;AAEO,SAAS,QAAQ,WAAmB,UAA8B;AACvE,MAAI,EAAE,QAAQ,MAAM,IAAID,QAAO,OAAO,WAAW,aAAa;AAC9D,MAAI,WAAW,aAAa;AAC1B,UAAM,IAAI,MAAM,kBAAkB,8BAA8B;AAAA,EAClE;AACA,MAAI,IAAI,IAAI,WAAWA,QAAO,UAAU,KAAK,CAAC;AAE9C,MAAI,UAAU,EAAE;AAChB,MAAI,YAAY,GAAM;AACpB,UAAM,IAAI,MAAM,mBAAmB,wBAAwB;AAAA,EAC7D;AAEA,MAAI,OAAO,EAAE;AACb,MAAI,IAAI,KAAK;AAEb,MAAI,OAAO,EAAE,MAAM,GAAG,IAAI,EAAE;AAC5B,MAAI,QAAQ,EAAE,MAAM,IAAI,IAAI,IAAI,KAAK,EAAE;AACvC,MAAI,MAAM,EAAE,IAAI,KAAK;AACrB,MAAI,MAAM,WAAW,KAAK,CAAC,GAAG,CAAC;AAC/B,MAAI,aAAa,EAAE,MAAM,IAAI,KAAK,KAAK,CAAC;AAExC,MAAI,MAAM,OAAO,SAAS,UAAU,MAAM,GAAG,MAAM,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,OAAO,GAAG,CAAC;AAClF,MAAI,QAAQ,kBAAkB,KAAK,OAAO,GAAG;AAC7C,MAAI,MAAM,MAAM,QAAQ,UAAU;AAElC,SAAO;AACT;",
  "names": ["concatBytes", "bech32", "concatBytes"]
}
