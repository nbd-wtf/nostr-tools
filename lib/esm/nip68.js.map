{
  "version": 3,
  "sources": ["../../nip44.ts", "../../utils.ts", "../../pure.ts", "../../core.ts", "../../nip68.ts"],
  "sourcesContent": ["import { chacha20 } from '@noble/ciphers/chacha'\nimport { equalBytes } from '@noble/ciphers/utils'\nimport { secp256k1 } from '@noble/curves/secp256k1'\nimport { extract as hkdf_extract, expand as hkdf_expand } from '@noble/hashes/hkdf'\nimport { hmac } from '@noble/hashes/hmac'\nimport { sha256 } from '@noble/hashes/sha256'\nimport { concatBytes, randomBytes } from '@noble/hashes/utils'\nimport { base64 } from '@scure/base'\n\nimport { utf8Decoder, utf8Encoder } from './utils.ts'\n\nconst minPlaintextSize = 0x0001 // 1b msg => padded to 32b\nconst maxPlaintextSize = 0xffff // 65535 (64kb-1) => padded to 64kb\n\nexport function getConversationKey(privkeyA: Uint8Array, pubkeyB: string): Uint8Array {\n  const sharedX = secp256k1.getSharedSecret(privkeyA, '02' + pubkeyB).subarray(1, 33)\n  return hkdf_extract(sha256, sharedX, 'nip44-v2')\n}\n\nfunction getMessageKeys(\n  conversationKey: Uint8Array,\n  nonce: Uint8Array,\n): { chacha_key: Uint8Array; chacha_nonce: Uint8Array; hmac_key: Uint8Array } {\n  const keys = hkdf_expand(sha256, conversationKey, nonce, 76)\n  return {\n    chacha_key: keys.subarray(0, 32),\n    chacha_nonce: keys.subarray(32, 44),\n    hmac_key: keys.subarray(44, 76),\n  }\n}\n\nfunction calcPaddedLen(len: number): number {\n  if (!Number.isSafeInteger(len) || len < 1) throw new Error('expected positive integer')\n  if (len <= 32) return 32\n  const nextPower = 1 << (Math.floor(Math.log2(len - 1)) + 1)\n  const chunk = nextPower <= 256 ? 32 : nextPower / 8\n  return chunk * (Math.floor((len - 1) / chunk) + 1)\n}\n\nfunction writeU16BE(num: number): Uint8Array {\n  if (!Number.isSafeInteger(num) || num < minPlaintextSize || num > maxPlaintextSize)\n    throw new Error('invalid plaintext size: must be between 1 and 65535 bytes')\n  const arr = new Uint8Array(2)\n  new DataView(arr.buffer).setUint16(0, num, false)\n  return arr\n}\n\nfunction pad(plaintext: string): Uint8Array {\n  const unpadded = utf8Encoder.encode(plaintext)\n  const unpaddedLen = unpadded.length\n  const prefix = writeU16BE(unpaddedLen)\n  const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen)\n  return concatBytes(prefix, unpadded, suffix)\n}\n\nfunction unpad(padded: Uint8Array): string {\n  const unpaddedLen = new DataView(padded.buffer).getUint16(0)\n  const unpadded = padded.subarray(2, 2 + unpaddedLen)\n  if (\n    unpaddedLen < minPlaintextSize ||\n    unpaddedLen > maxPlaintextSize ||\n    unpadded.length !== unpaddedLen ||\n    padded.length !== 2 + calcPaddedLen(unpaddedLen)\n  )\n    throw new Error('invalid padding')\n  return utf8Decoder.decode(unpadded)\n}\n\nfunction hmacAad(key: Uint8Array, message: Uint8Array, aad: Uint8Array): Uint8Array {\n  if (aad.length !== 32) throw new Error('AAD associated data must be 32 bytes')\n  const combined = concatBytes(aad, message)\n  return hmac(sha256, key, combined)\n}\n\n// metadata: always 65b (version: 1b, nonce: 32b, max: 32b)\n// plaintext: 1b to 0xffff\n// padded plaintext: 32b to 0xffff\n// ciphertext: 32b+2 to 0xffff+2\n// raw payload: 99 (65+32+2) to 65603 (65+0xffff+2)\n// compressed payload (base64): 132b to 87472b\nfunction decodePayload(payload: string): { nonce: Uint8Array; ciphertext: Uint8Array; mac: Uint8Array } {\n  if (typeof payload !== 'string') throw new Error('payload must be a valid string')\n  const plen = payload.length\n  if (plen < 132 || plen > 87472) throw new Error('invalid payload length: ' + plen)\n  if (payload[0] === '#') throw new Error('unknown encryption version')\n  let data: Uint8Array\n  try {\n    data = base64.decode(payload)\n  } catch (error) {\n    throw new Error('invalid base64: ' + (error as any).message)\n  }\n  const dlen = data.length\n  if (dlen < 99 || dlen > 65603) throw new Error('invalid data length: ' + dlen)\n  const vers = data[0]\n  if (vers !== 2) throw new Error('unknown encryption version ' + vers)\n  return {\n    nonce: data.subarray(1, 33),\n    ciphertext: data.subarray(33, -32),\n    mac: data.subarray(-32),\n  }\n}\n\nexport function encrypt(plaintext: string, conversationKey: Uint8Array, nonce: Uint8Array = randomBytes(32)): string {\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce)\n  const padded = pad(plaintext)\n  const ciphertext = chacha20(chacha_key, chacha_nonce, padded)\n  const mac = hmacAad(hmac_key, ciphertext, nonce)\n  return base64.encode(concatBytes(new Uint8Array([2]), nonce, ciphertext, mac))\n}\n\nexport function decrypt(payload: string, conversationKey: Uint8Array): string {\n  const { nonce, ciphertext, mac } = decodePayload(payload)\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce)\n  const calculatedMac = hmacAad(hmac_key, ciphertext, nonce)\n  if (!equalBytes(calculatedMac, mac)) throw new Error('invalid MAC')\n  const padded = chacha20(chacha_key, chacha_nonce, ciphertext)\n  return unpad(padded)\n}\n\nexport const v2 = {\n  utils: {\n    getConversationKey,\n    calcPaddedLen,\n  },\n  encrypt,\n  decrypt,\n}\n", "import type { Event } from './core.ts'\n\nexport const utf8Decoder: TextDecoder = new TextDecoder('utf-8')\nexport const utf8Encoder: TextEncoder = new TextEncoder()\n\nexport function normalizeURL(url: string): string {\n  if (url.indexOf('://') === -1) url = 'wss://' + url\n  let p = new URL(url)\n  p.pathname = p.pathname.replace(/\\/+/g, '/')\n  if (p.pathname.endsWith('/')) p.pathname = p.pathname.slice(0, -1)\n  if ((p.port === '80' && p.protocol === 'ws:') || (p.port === '443' && p.protocol === 'wss:')) p.port = ''\n  p.searchParams.sort()\n  p.hash = ''\n  return p.toString()\n}\n\nexport function insertEventIntoDescendingList(sortedArray: Event[], event: Event): Event[] {\n  const [idx, found] = binarySearch(sortedArray, b => {\n    if (event.id === b.id) return 0\n    if (event.created_at === b.created_at) return -1\n    return b.created_at - event.created_at\n  })\n  if (!found) {\n    sortedArray.splice(idx, 0, event)\n  }\n  return sortedArray\n}\n\nexport function insertEventIntoAscendingList(sortedArray: Event[], event: Event): Event[] {\n  const [idx, found] = binarySearch(sortedArray, b => {\n    if (event.id === b.id) return 0\n    if (event.created_at === b.created_at) return -1\n    return event.created_at - b.created_at\n  })\n  if (!found) {\n    sortedArray.splice(idx, 0, event)\n  }\n  return sortedArray\n}\n\nexport function binarySearch<T>(arr: T[], compare: (b: T) => number): [number, boolean] {\n  let start = 0\n  let end = arr.length - 1\n\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2)\n    const cmp = compare(arr[mid])\n\n    if (cmp === 0) {\n      return [mid, true]\n    }\n\n    if (cmp < 0) {\n      end = mid - 1\n    } else {\n      start = mid + 1\n    }\n  }\n\n  return [start, false]\n}\n\nexport class QueueNode<V> {\n  public value: V\n  public next: QueueNode<V> | null = null\n  public prev: QueueNode<V> | null = null\n\n  constructor(message: V) {\n    this.value = message\n  }\n}\n\nexport class Queue<V> {\n  public first: QueueNode<V> | null\n  public last: QueueNode<V> | null\n\n  constructor() {\n    this.first = null\n    this.last = null\n  }\n\n  enqueue(value: V): boolean {\n    const newNode = new QueueNode(value)\n    if (!this.last) {\n      // list is empty\n      this.first = newNode\n      this.last = newNode\n    } else if (this.last === this.first) {\n      // list has a single element\n      this.last = newNode\n      this.last.prev = this.first\n      this.first.next = newNode\n    } else {\n      // list has elements, add as last\n      newNode.prev = this.last\n      this.last.next = newNode\n      this.last = newNode\n    }\n    return true\n  }\n\n  dequeue(): V | null {\n    if (!this.first) return null\n\n    if (this.first === this.last) {\n      const target = this.first\n      this.first = null\n      this.last = null\n      return target.value\n    }\n\n    const target = this.first\n    this.first = target.next\n\n    return target.value\n  }\n}\n", "import { schnorr } from '@noble/curves/secp256k1'\nimport { bytesToHex } from '@noble/hashes/utils'\nimport { Nostr, Event, EventTemplate, UnsignedEvent, VerifiedEvent, verifiedSymbol, validateEvent } from './core.ts'\nimport { sha256 } from '@noble/hashes/sha256'\n\nimport { utf8Encoder } from './utils.ts'\n\nclass JS implements Nostr {\n  generateSecretKey(): Uint8Array {\n    return schnorr.utils.randomPrivateKey()\n  }\n  getPublicKey(secretKey: Uint8Array): string {\n    return bytesToHex(schnorr.getPublicKey(secretKey))\n  }\n  finalizeEvent(t: EventTemplate, secretKey: Uint8Array): VerifiedEvent {\n    const event = t as VerifiedEvent\n    event.pubkey = bytesToHex(schnorr.getPublicKey(secretKey))\n    event.id = getEventHash(event)\n    event.sig = bytesToHex(schnorr.sign(getEventHash(event), secretKey))\n    event[verifiedSymbol] = true\n    return event\n  }\n  verifyEvent(event: Event): event is VerifiedEvent {\n    if (typeof event[verifiedSymbol] === 'boolean') return event[verifiedSymbol]\n\n    const hash = getEventHash(event)\n    if (hash !== event.id) {\n      event[verifiedSymbol] = false\n      return false\n    }\n\n    try {\n      const valid = schnorr.verify(event.sig, hash, event.pubkey)\n      event[verifiedSymbol] = valid\n      return valid\n    } catch (err) {\n      event[verifiedSymbol] = false\n      return false\n    }\n  }\n}\n\nexport function serializeEvent(evt: UnsignedEvent): string {\n  if (!validateEvent(evt)) throw new Error(\"can't serialize event with wrong or missing properties\")\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])\n}\n\nexport function getEventHash(event: UnsignedEvent): string {\n  let eventHash = sha256(utf8Encoder.encode(serializeEvent(event)))\n  return bytesToHex(eventHash)\n}\n\nconst i: JS = new JS()\n\nexport const generateSecretKey = i.generateSecretKey\nexport const getPublicKey = i.getPublicKey\nexport const finalizeEvent = i.finalizeEvent\nexport const verifyEvent = i.verifyEvent\nexport * from './core.ts'\n", "export interface Nostr {\n  generateSecretKey(): Uint8Array\n  getPublicKey(secretKey: Uint8Array): string\n  finalizeEvent(event: EventTemplate, secretKey: Uint8Array): VerifiedEvent\n  verifyEvent(event: Event): event is VerifiedEvent\n}\n\n/** Designates a verified event signature. */\nexport const verifiedSymbol = Symbol('verified')\n\nexport interface Event {\n  kind: number\n  tags: string[][]\n  content: string\n  created_at: number\n  pubkey: string\n  id: string\n  sig: string\n  [verifiedSymbol]?: boolean\n}\n\nexport type NostrEvent = Event\nexport type EventTemplate = Pick<Event, 'kind' | 'tags' | 'content' | 'created_at'>\nexport type UnsignedEvent = Pick<Event, 'kind' | 'tags' | 'content' | 'created_at' | 'pubkey'>\n\n/** An event whose signature has been verified. */\nexport interface VerifiedEvent extends Event {\n  [verifiedSymbol]: true\n}\n\nconst isRecord = (obj: unknown): obj is Record<string, unknown> => obj instanceof Object\n\nexport function validateEvent<T>(event: T): event is T & UnsignedEvent {\n  if (!isRecord(event)) return false\n  if (typeof event.kind !== 'number') return false\n  if (typeof event.content !== 'string') return false\n  if (typeof event.created_at !== 'number') return false\n  if (typeof event.pubkey !== 'string') return false\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/)) return false\n\n  if (!Array.isArray(event.tags)) return false\n  for (let i = 0; i < event.tags.length; i++) {\n    let tag = event.tags[i]\n    if (!Array.isArray(tag)) return false\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === 'object') return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Sort events in reverse-chronological order by the `created_at` timestamp,\n * and then by the event `id` (lexicographically) in case of ties.\n * This mutates the array.\n */\nexport function sortEvents(events: Event[]): Event[] {\n  return events.sort((a: NostrEvent, b: NostrEvent): number => {\n    if (a.created_at !== b.created_at) {\n      return b.created_at - a.created_at\n    }\n    return a.id.localeCompare(b.id)\n  })\n}\n", "import { decrypt, encrypt, getConversationKey } from './nip44.ts'\nimport { finalizeEvent, getPublicKey } from './pure.ts'\nimport { AbstractSimplePool, SubCloser } from './abstract-pool.ts'\nexport type RecurringDebitTimeUnit = 'day' | 'week' | 'month'\nexport type RecurringDebit = { pointer?: string, frequency: { number: number, unit: RecurringDebitTimeUnit }, amount_sats: number }\nexport type SingleDebit = { pointer?: string, amount_sats?: number, bolt11: string, frequency?: undefined }\nexport type NdebitData = RecurringDebit | SingleDebit\nexport type NdebitSuccess = { res: 'ok' }\nexport type NdebitSuccessPayment = { res: 'ok', preimage: string }\nexport type NdebitFailure = { res: 'GFY', error: string, code: number }\nexport type Nip68Response = NdebitSuccess | NdebitSuccessPayment | NdebitFailure\n\nexport const SendNdebitRequest = async (pool: AbstractSimplePool, privateKey: Uint8Array, relays: string[], pubKey: string, data: NdebitData): Promise<Nip68Response> => {\n    const publicKey = getPublicKey(privateKey)\n    const content = encrypt(JSON.stringify(data), getConversationKey(privateKey, pubKey))\n    const event = newNip68Event(content, publicKey, pubKey)\n    const signed = finalizeEvent(event, privateKey)\n    await Promise.all(pool.publish(relays, signed))\n    return new Promise<Nip68Response>((res, rej) => {\n        let closer: SubCloser = { close: () => { } }\n        const timeout = setTimeout(() => {\n            closer.close(); rej('failed to get nip69 response in time')\n        }, 30 * 1000)\n\n        closer = pool.subscribeMany(relays, [newNip68Filter(publicKey, signed.id)], {\n            onevent: async (e) => {\n                clearTimeout(timeout)\n                const content = decrypt(e.content, getConversationKey(privateKey, pubKey))\n                res(JSON.parse(content))\n            }\n        })\n    })\n}\n\nexport const newNip68Event = (content: string, fromPub: string, toPub: string) => ({\n    content,\n    created_at: Math.floor(Date.now() / 1000),\n    kind: 21002,\n    pubkey: fromPub,\n    tags: [['p', toPub]]\n})\n\nexport const newNip68Filter = (publicKey: string, eventId: string) => ({\n    since: Math.floor(Date.now() / 1000) - 1,\n    kinds: [21002],\n    '#p': [publicKey],\n    '#e': [eventId]\n})\n"],
  "mappings": "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",
  "names": ["i", "sha256", "sha256", "content"]
}
