{
  "version": 3,
  "sources": ["../../nip10.ts"],
  "sourcesContent": ["import type { Event } from './core.ts'\nimport type { EventPointer, ProfilePointer } from './nip19.ts'\n\nexport function parse(event: Pick<Event, 'tags'>): {\n  /**\n   * Pointer to the root of the thread.\n   */\n  root: EventPointer | undefined\n\n  /**\n   * Pointer to a \"parent\" event that parsed event replies to (responded to).\n   */\n  reply: EventPointer | undefined\n\n  /**\n   * Pointers to events that may or may not be in the reply chain.\n   */\n  mentions: EventPointer[]\n\n  /**\n   * Pointers to events that were directly quoted.\n   */\n  quotes: EventPointer[]\n\n  /**\n   * List of pubkeys that are involved in the thread in no particular order.\n   */\n  profiles: ProfilePointer[]\n} {\n  const result: ReturnType<typeof parse> = {\n    reply: undefined,\n    root: undefined,\n    mentions: [],\n    profiles: [],\n    quotes: [],\n  }\n\n  let maybeParent: EventPointer | undefined\n  let maybeRoot: EventPointer | undefined\n\n  for (let i = event.tags.length - 1; i >= 0; i--) {\n    const tag = event.tags[i]\n\n    if (tag[0] === 'e' && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl, eTagMarker, eTagAuthor] = tag as [\n        string,\n        string,\n        undefined | string,\n        undefined | string,\n        undefined | string,\n      ]\n\n      const eventPointer: EventPointer = {\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : [],\n        author: eTagAuthor,\n      }\n\n      if (eTagMarker === 'root') {\n        result.root = eventPointer\n        continue\n      }\n\n      if (eTagMarker === 'reply') {\n        result.reply = eventPointer\n        continue\n      }\n\n      if (eTagMarker === 'mention') {\n        result.mentions.push(eventPointer)\n        continue\n      }\n\n      if (!maybeParent) {\n        maybeParent = eventPointer\n      } else {\n        maybeRoot = eventPointer\n      }\n\n      result.mentions.push(eventPointer)\n      continue\n    }\n\n    if (tag[0] === 'q' && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl] = tag as [string, string, undefined | string]\n      result.quotes.push({\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : [],\n      })\n    }\n\n    if (tag[0] === 'p' && tag[1]) {\n      result.profiles.push({\n        pubkey: tag[1],\n        relays: tag[2] ? [tag[2]] : [],\n      })\n      continue\n    }\n  }\n\n  // get legacy (positional) markers, set reply to root and vice-versa if one of them is missing\n  if (!result.root) {\n    result.root = maybeRoot || maybeParent || result.reply\n  }\n  if (!result.reply) {\n    result.reply = maybeParent || result.root\n  }\n\n  // remove root and reply from mentions, inherit relay hints from authors if any\n  ;[result.reply, result.root].forEach(ref => {\n    if (!ref) return\n\n    let idx = result.mentions.indexOf(ref)\n    if (idx !== -1) {\n      result.mentions.splice(idx, 1)\n    }\n    if (ref.author) {\n      let author = result.profiles.find(p => p.pubkey === ref.author)\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = []\n        }\n        author.relays.forEach(url => {\n          if (ref.relays!?.indexOf(url) === -1) ref.relays!.push(url)\n        })\n        author.relays = ref.relays\n      }\n    }\n  })\n\n  result.mentions.forEach(ref => {\n    if (ref!.author) {\n      let author = result.profiles.find(p => p.pubkey === ref.author)\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = []\n        }\n        author.relays.forEach(url => {\n          if (ref.relays!.indexOf(url) === -1) ref.relays!.push(url)\n        })\n        author.relays = ref.relays\n      }\n    }\n  })\n\n  return result\n}\n"],
  "mappings": "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",
  "names": []
}
