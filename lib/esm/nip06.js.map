{
  "version": 3,
  "sources": ["../../nip06.ts"],
  "sourcesContent": ["import { bytesToHex } from '@noble/hashes/utils'\nimport { wordlist } from '@scure/bip39/wordlists/english'\nimport { generateMnemonic, mnemonicToSeedSync, validateMnemonic } from '@scure/bip39'\nimport { HDKey } from '@scure/bip32'\n\nconst DERIVATION_PATH = `m/44'/1237'`\n\nexport function privateKeyFromSeedWords(mnemonic: string, passphrase?: string, accountIndex = 0): Uint8Array {\n  let root = HDKey.fromMasterSeed(mnemonicToSeedSync(mnemonic, passphrase))\n  let privateKey = root.derive(`${DERIVATION_PATH}/${accountIndex}'/0/0`).privateKey\n  if (!privateKey) throw new Error('could not derive private key')\n  return privateKey\n}\n\nexport function accountFromSeedWords(\n  mnemonic: string,\n  passphrase?: string,\n  accountIndex = 0,\n): {\n  privateKey: Uint8Array\n  publicKey: string\n} {\n  const root = HDKey.fromMasterSeed(mnemonicToSeedSync(mnemonic, passphrase))\n  const seed = root.derive(`${DERIVATION_PATH}/${accountIndex}'/0/0`)\n  const publicKey = bytesToHex(seed.publicKey!.slice(1))\n  const privateKey = seed.privateKey\n  if (!privateKey || !publicKey) {\n    throw new Error('could not derive key pair')\n  }\n  return { privateKey, publicKey }\n}\n\nexport function extendedKeysFromSeedWords(\n  mnemonic: string,\n  passphrase?: string,\n  extendedAccountIndex = 0,\n): {\n  privateExtendedKey: string\n  publicExtendedKey: string\n} {\n  let root = HDKey.fromMasterSeed(mnemonicToSeedSync(mnemonic, passphrase))\n  let seed = root.derive(`${DERIVATION_PATH}/${extendedAccountIndex}'`)\n  let privateExtendedKey = seed.privateExtendedKey\n  let publicExtendedKey = seed.publicExtendedKey\n  if (!privateExtendedKey && !publicExtendedKey) throw new Error('could not derive extended key pair')\n  return { privateExtendedKey, publicExtendedKey }\n}\n\nexport function accountFromExtendedKey(\n  base58key: string,\n  accountIndex = 0,\n): {\n  privateKey?: Uint8Array\n  publicKey: string\n} {\n  let extendedKey = HDKey.fromExtendedKey(base58key)\n  let version = base58key.slice(0, 4)\n  let child = extendedKey.deriveChild(0).deriveChild(accountIndex)\n  let publicKey = bytesToHex(child.publicKey!.slice(1))\n  if (!publicKey) throw new Error('could not derive public key')\n  if (version === 'xprv') {\n    let privateKey = child.privateKey!\n    if (!privateKey) throw new Error('could not derive private key')\n    return { privateKey, publicKey }\n  }\n  return { publicKey }\n}\n\nexport function generateSeedWords(): string {\n  return generateMnemonic(wordlist)\n}\n\nexport function validateWords(words: string): boolean {\n  return validateMnemonic(words, wordlist)\n}\n"],
  "mappings": ";AAAA,SAAS,kBAAkB;AAC3B,SAAS,gBAAgB;AACzB,SAAS,kBAAkB,oBAAoB,wBAAwB;AACvE,SAAS,aAAa;AAEtB,IAAM,kBAAkB;AAEjB,SAAS,wBAAwB,UAAkB,YAAqB,eAAe,GAAe;AAC3G,MAAI,OAAO,MAAM,eAAe,mBAAmB,UAAU,UAAU,CAAC;AACxE,MAAI,aAAa,KAAK,OAAO,GAAG,mBAAmB,mBAAmB,EAAE;AACxE,MAAI,CAAC;AAAY,UAAM,IAAI,MAAM,8BAA8B;AAC/D,SAAO;AACT;AAEO,SAAS,qBACd,UACA,YACA,eAAe,GAIf;AACA,QAAM,OAAO,MAAM,eAAe,mBAAmB,UAAU,UAAU,CAAC;AAC1E,QAAM,OAAO,KAAK,OAAO,GAAG,mBAAmB,mBAAmB;AAClE,QAAM,YAAY,WAAW,KAAK,UAAW,MAAM,CAAC,CAAC;AACrD,QAAM,aAAa,KAAK;AACxB,MAAI,CAAC,cAAc,CAAC,WAAW;AAC7B,UAAM,IAAI,MAAM,2BAA2B;AAAA,EAC7C;AACA,SAAO,EAAE,YAAY,UAAU;AACjC;AAEO,SAAS,0BACd,UACA,YACA,uBAAuB,GAIvB;AACA,MAAI,OAAO,MAAM,eAAe,mBAAmB,UAAU,UAAU,CAAC;AACxE,MAAI,OAAO,KAAK,OAAO,GAAG,mBAAmB,uBAAuB;AACpE,MAAI,qBAAqB,KAAK;AAC9B,MAAI,oBAAoB,KAAK;AAC7B,MAAI,CAAC,sBAAsB,CAAC;AAAmB,UAAM,IAAI,MAAM,oCAAoC;AACnG,SAAO,EAAE,oBAAoB,kBAAkB;AACjD;AAEO,SAAS,uBACd,WACA,eAAe,GAIf;AACA,MAAI,cAAc,MAAM,gBAAgB,SAAS;AACjD,MAAI,UAAU,UAAU,MAAM,GAAG,CAAC;AAClC,MAAI,QAAQ,YAAY,YAAY,CAAC,EAAE,YAAY,YAAY;AAC/D,MAAI,YAAY,WAAW,MAAM,UAAW,MAAM,CAAC,CAAC;AACpD,MAAI,CAAC;AAAW,UAAM,IAAI,MAAM,6BAA6B;AAC7D,MAAI,YAAY,QAAQ;AACtB,QAAI,aAAa,MAAM;AACvB,QAAI,CAAC;AAAY,YAAM,IAAI,MAAM,8BAA8B;AAC/D,WAAO,EAAE,YAAY,UAAU;AAAA,EACjC;AACA,SAAO,EAAE,UAAU;AACrB;AAEO,SAAS,oBAA4B;AAC1C,SAAO,iBAAiB,QAAQ;AAClC;AAEO,SAAS,cAAc,OAAwB;AACpD,SAAO,iBAAiB,OAAO,QAAQ;AACzC;",
  "names": []
}
