{
  "version": 3,
  "sources": ["../../nip11.ts", "../../nip19.ts", "../../utils.ts", "../../nip29.ts"],
  "sourcesContent": ["var _fetch: any\n\ntry {\n  _fetch = fetch\n} catch {}\n\nexport function useFetchImplementation(fetchImplementation: any): void {\n  _fetch = fetchImplementation\n}\n\nexport async function fetchRelayInformation(url: string): Promise<RelayInformation> {\n  return (await (\n    await fetch(url.replace('ws://', 'http://').replace('wss://', 'https://'), {\n      headers: { Accept: 'application/nostr+json' },\n    })\n  ).json()) as RelayInformation\n}\n\n/**\n * ## Relay Information Document\n\n * Relays may provide server metadata to clients to inform\n * them of capabilities, administrative contacts, and\n * various server attributes. This is made available as a\n * JSON document over HTTP, on the same URI as the relay's\n * websocket.\n\n * Any field may be omitted, and clients MUST ignore any\n * additional fields they do not understand. Relays MUST\n * accept CORS requests by sending\n * `Access-Control-Allow-Origin`,\n * `Access-Control-Allow-Headers`, and\n * `Access-Control-Allow-Methods` headers.\n * @param name string identifying relay\n * @param description string with detailed information\n * @param pubkey administrative contact pubkey\n * @param contact: administrative alternate contact\n * @param supported_nips a list of NIP numbers supported by\n * the relay\n * @param software identifying relay software URL\n * @param version string version identifier\n */\nexport interface BasicRelayInformation {\n  // string identifying relay\n  name: string\n  description: string\n  pubkey: string\n  contact: string\n  supported_nips: number[]\n  software: string\n  version: string\n  // limitation?: Limitations<A, P>\n}\n\n/**\n *  * ## Extra Fields\n\n *  * ### Server Limitations\n\n * These are limitations imposed by the relay on clients.\n * Your client should expect that requests which exceed\n * these practical_ limitations are rejected or fail immediately.\n * @param max_message_length this is the maximum number of\n * bytes for incoming JSON that the relay will attempt to\n * decode and act upon. When you send large subscriptions,\n * you will be limited by this value. It also effectively\n * limits the maximum size of any event. Value is calculated\n * from `[` to `]` and is after UTF-8 serialization (so some\n * unicode characters will cost 2-3 bytes). It is equal to\n * the maximum size of the WebSocket message frame.\n * @param max_subscriptions total number of subscriptions\n * that may be active on a single websocket connection to\n * this relay. It's possible that authenticated clients with\n * a (paid) relationship to the relay may have higher limits.\n * @param max_filters maximum number of filter values in\n * each subscription. Must be one or higher.\n * @param max_limit the relay server will clamp each\n * filter's `limit` value to this number.\n * This means the client won't be able to get more than this\n * number of events from a single subscription filter. This\n * clamping is typically done silently by the relay, but\n * with this number, you can know that there are additional\n * results if you narrowed your filter's time range or other\n * parameters.\n * @param max_subid_length maximum length of subscription id as a\n * string.\n * @param min_prefix for `authors` and `ids` filters which\n * are to match against a hex prefix, you must provide at\n * least this many hex digits in the prefix.\n * @param max_event_tags in any event, this is the maximum\n * number of elements in the `tags` list.\n * @param max_content_length maximum number of characters in\n * the `content` field of any event. This is a count of\n * unicode characters. After serializing into JSON it may be\n * larger (in bytes), and is still subject to the\n * max_message_length`, if defined.\n * @param min_pow_difficulty new events will require at\n * least this difficulty of PoW, based on [NIP-13](13.md),\n * or they will be rejected by this server.\n * @param auth_required this relay requires [NIP-42](42.md)\n * authentication to happen before a new connection may\n * perform any other action. Even if set to False,\n * authentication may be required for specific actions.\n * @param restricted_writes: this relay requires some kind\n * of condition to be fulfilled in order to accept events\n * (not necessarily, but including\n * @param payment_required this relay requires payment\n * before a new connection may perform any action.\n * @param created_at_lower_limit: 'created_at' lower limit\n * @param created_at_upper_limit: 'created_at' upper limit\n */\nexport interface Limitations {\n  max_message_length: number\n  max_subscriptions: number\n  max_filters: number\n  max_limit: number\n  max_subid_length: number\n  min_prefix: number\n  max_event_tags: number\n  max_content_length: number\n  min_pow_difficulty: number\n  auth_required: boolean\n  payment_required: boolean\n  created_at_lower_limit: number\n  created_at_upper_limit: number\n  restricted_writes: boolean\n}\n\ninterface RetentionDetails {\n  kinds: (number | number[])[]\n  time?: number | null\n  count?: number | null\n}\ntype AnyRetentionDetails = RetentionDetails\n/**\n * ### Event Retention\n\n * There may be a cost associated with storing data forever,\n * so relays may wish to state retention times. The values\n * stated here are defaults for unauthenticated users and\n * visitors. Paid users would likely have other policies.\n\n * Retention times are given in seconds, with `null`\n * indicating infinity. If zero is provided, this means the\n * event will not be stored at all, and preferably an error\n * will be provided when those are received.\n * ```json\n{\n...\n  \"retention\": [\n    { \"kinds\": [0, 1, [5, 7], [40, 49]], \"time\": 3600 },\n    { \"kinds\": [[40000, 49999]], \"time\": 100 },\n    { \"kinds\": [[30000, 39999]], \"count\": 1000 },\n    { \"time\": 3600, \"count\": 10000 }\n  ]\n...\n}\n```\n * @param retention is a list of specifications: each will\n * apply to either all kinds, or a subset of kinds. Ranges\n * may be specified for the kind field as a tuple of\n * inclusive start and end values. Events of indicated kind\n * (or all) are then limited to a `count` and/or time\n * period.\n\n * It is possible to effectively blacklist Nostr-based\n * protocols that rely on a specific `kind` number, by\n * giving a retention time of zero for those `kind` values.\n * While that is unfortunate, it does allow clients to\n * discover servers that will support their protocol quickly\n * via a single HTTP fetch.\n\n * There is no need to specify retention times for\n * _ephemeral events_ as defined in [NIP-16](16.md) since\n * they are not retained.\n */\nexport interface Retention {\n  retention: AnyRetentionDetails[]\n}\n\n/**\n * Some relays may be governed by the arbitrary laws of a\n * nation state. This may limit what content can be stored\n * in cleartext on those relays. All clients are encouraged\n * to use encryption to work around this limitation.\n\n * It is not possible to describe the limitations of each\n * country's laws and policies which themselves are\n * typically vague and constantly shifting.\n\n * Therefore, this field allows the relay operator to\n * indicate which countries' laws might end up being\n * enforced on them, and then indirectly on their users'\n * content.\n\n * Users should be able to avoid relays in countries they\n * don't like, and/or select relays in more favourable\n * zones. Exposing this flexibility is up to the client\n * software.\n\n * @param relay_countries a list of two-level ISO country\n * codes (ISO 3166-1 alpha-2) whose laws and policies may\n * affect this relay. `EU` may be used for European Union\n * countries.\n\n * Remember that a relay may be hosted in a country which is\n * not the country of the legal entities who own the relay,\n * so it's very likely a number of countries are involved.\n */\nexport interface ContentLimitations {\n  relay_countries: string[]\n}\n\n/**\n * ### Community Preferences\n\n * For public text notes at least, a relay may try to foster\n * a local community. This would encourage users to follow\n * the global feed on that relay, in addition to their usual\n * individual follows. To support this goal, relays MAY\n * specify some of the following values.\n\n * @param language_tags  is an ordered list of [IETF\n * language\n * tags](https://en.wikipedia.org/wiki/IETF_language_tag\n * indicating the major languages spoken on the relay.\n * @param tags is a list of limitations on the topics to be\n * discussed. For example `sfw-only` indicates that only\n * \"Safe For Work\" content is encouraged on this relay. This\n * relies on assumptions of what the \"work\" \"community\"\n * feels \"safe\" talking about. In time, a common set of tags\n * may emerge that allow users to find relays that suit\n * their needs, and client software will be able to parse\n * these tags easily. The `bitcoin-only` tag indicates that\n * any _altcoin_, _\"crypto\"_ or _blockchain_ comments will\n * be ridiculed without mercy.\n * @param posting_policy is a link to a human-readable page\n * which specifies the community policies for the relay. In\n * cases where `sfw-only` is True, it's important to link to\n * a page which gets into the specifics of your posting\n * policy.\n\n * The `description` field should be used to describe your\n * community goals and values, in brief. The\n * `posting_policy` is for additional detail and legal\n * terms. Use the `tags` field to signify limitations on\n * content, or topics to be discussed, which could be\n * machine processed by appropriate client software.\n */\nexport interface CommunityPreferences {\n  language_tags: string[]\n  tags: string[]\n  posting_policy: string\n}\n\nexport interface Amount {\n  amount: number\n  unit: 'msat'\n}\nexport interface PublicationAmount extends Amount {\n  kinds: number[]\n}\nexport interface Subscription extends Amount {\n  period: number\n}\nexport interface Fees {\n  admission: Amount[]\n  subscription: Subscription[]\n  publication: PublicationAmount[]\n}\n/**\n * Relays that require payments may want to expose their fee\n * schedules.\n */\nexport interface PayToRelay {\n  payments_url: string\n  fees: Fees\n}\n\n/**\n * A URL pointing to an image to be used as an icon for the\n * relay. Recommended to be squared in shape.\n */\nexport interface Icon {\n  icon: string\n}\n\nexport type RelayInformation = BasicRelayInformation &\n  Partial<Retention> & {\n    limitation?: Partial<Limitations>\n  } & Partial<ContentLimitations> &\n  Partial<CommunityPreferences> &\n  Partial<PayToRelay> &\n  Partial<Icon>\n", "import { bytesToHex, concatBytes, hexToBytes } from '@noble/hashes/utils'\nimport { bech32 } from '@scure/base'\n\nimport { utf8Decoder, utf8Encoder } from './utils.ts'\n\nexport type NProfile = `nprofile1${string}`\nexport type NEvent = `nevent1${string}`\nexport type NAddr = `naddr1${string}`\nexport type NSec = `nsec1${string}`\nexport type NPub = `npub1${string}`\nexport type Note = `note1${string}`\nexport type Ncryptsec = `ncryptsec1${string}`\nexport type Noffer = `noffer1${string}`\nexport type Ndebit = `ndebit1${string}`\n\nexport const NostrTypeGuard = {\n  isNProfile: (value?: string | null): value is NProfile => /^nprofile1[a-z\\d]+$/.test(value || ''),\n  isNEvent: (value?: string | null): value is NEvent => /^nevent1[a-z\\d]+$/.test(value || ''),\n  isNAddr: (value?: string | null): value is NAddr => /^naddr1[a-z\\d]+$/.test(value || ''),\n  isNSec: (value?: string | null): value is NSec => /^nsec1[a-z\\d]{58}$/.test(value || ''),\n  isNPub: (value?: string | null): value is NPub => /^npub1[a-z\\d]{58}$/.test(value || ''),\n  isNote: (value?: string | null): value is Note => /^note1[a-z\\d]+$/.test(value || ''),\n  isNcryptsec: (value?: string | null): value is Ncryptsec => /^ncryptsec1[a-z\\d]+$/.test(value || ''),\n  isNoffer: (value?: string | null): value is Noffer => /^noffer1[a-z\\d]+$/.test(value || ''),\n  isNdebit: (value?: string | null): value is Ndebit => /^ndebit1[a-z\\d]+$/.test(value || ''),\n}\n\nexport const Bech32MaxSize = 5000\n\n/**\n * Bech32 regex.\n * @see https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32\n */\nexport const BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/\n\nfunction integerToUint8Array(number: number) {\n  // Create a Uint8Array with enough space to hold a 32-bit integer (4 bytes).\n  const uint8Array = new Uint8Array(4)\n\n  // Use bitwise operations to extract the bytes.\n  uint8Array[0] = (number >> 24) & 0xff // Most significant byte (MSB)\n  uint8Array[1] = (number >> 16) & 0xff\n  uint8Array[2] = (number >> 8) & 0xff\n  uint8Array[3] = number & 0xff // Least significant byte (LSB)\n\n  return uint8Array\n}\n\nexport type ProfilePointer = {\n  pubkey: string // hex\n  relays?: string[]\n}\n\nexport type EventPointer = {\n  id: string // hex\n  relays?: string[]\n  author?: string\n  kind?: number\n}\n\nexport type AddressPointer = {\n  identifier: string\n  pubkey: string\n  kind: number\n  relays?: string[]\n}\n\nexport type OfferPointer = {\n  pubkey: string,\n  relay: string,\n  offer: string\n  priceType: OfferPriceType,\n  price?: number\n}\nexport enum OfferPriceType {\n  Fixed = 0,\n  Variable = 1,\n  Spontaneous = 2,\n}\n\nexport type DebitPointer = {\n  pubkey: string,\n  relay: string,\n  pointer?: string,\n}\n\ntype Prefixes = {\n  nprofile: ProfilePointer\n  nevent: EventPointer\n  naddr: AddressPointer\n  nsec: Uint8Array\n  npub: string\n  note: string\n  noffer: OfferPointer\n  ndebit: DebitPointer\n}\n\ntype DecodeValue<Prefix extends keyof Prefixes> = {\n  type: Prefix\n  data: Prefixes[Prefix]\n}\n\nexport type DecodeResult = {\n  [P in keyof Prefixes]: DecodeValue<P>\n}[keyof Prefixes]\n\nexport function decode<Prefix extends keyof Prefixes>(nip19: `${Prefix}1${string}`): DecodeValue<Prefix>\nexport function decode(nip19: string): DecodeResult\nexport function decode(nip19: string): DecodeResult {\n  let { prefix, words } = bech32.decode(nip19, Bech32MaxSize)\n  let data = new Uint8Array(bech32.fromWords(words))\n\n  switch (prefix) {\n    case 'nprofile': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nprofile')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n\n      return {\n        type: 'nprofile',\n        data: {\n          pubkey: bytesToHex(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n        },\n      }\n    }\n    case 'nevent': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nevent')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n      if (tlv[2] && tlv[2][0].length !== 32) throw new Error('TLV 2 should be 32 bytes')\n      if (tlv[3] && tlv[3][0].length !== 4) throw new Error('TLV 3 should be 4 bytes')\n\n      return {\n        type: 'nevent',\n        data: {\n          id: bytesToHex(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0] ? bytesToHex(tlv[2][0]) : undefined,\n          kind: tlv[3]?.[0] ? parseInt(bytesToHex(tlv[3][0]), 16) : undefined,\n        },\n      }\n    }\n\n    case 'naddr': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for naddr')\n      if (!tlv[2]?.[0]) throw new Error('missing TLV 2 for naddr')\n      if (tlv[2][0].length !== 32) throw new Error('TLV 2 should be 32 bytes')\n      if (!tlv[3]?.[0]) throw new Error('missing TLV 3 for naddr')\n      if (tlv[3][0].length !== 4) throw new Error('TLV 3 should be 4 bytes')\n\n      return {\n        type: 'naddr',\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: bytesToHex(tlv[2][0]),\n          kind: parseInt(bytesToHex(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n        },\n      }\n    }\n\n    case 'nsec':\n      return { type: prefix, data }\n\n    case 'npub':\n    case 'note':\n      return { type: prefix, data: bytesToHex(data) }\n    case 'noffer': {\n      const tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for noffer')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n      if (!tlv[1]?.[0]) throw new Error('missing TLV 1 for noffer')\n      if (!tlv[2]?.[0]) throw new Error('missing TLV 2 for noffer')\n      if (!tlv[3]?.[0]) throw new Error('missing TLV 3 for noffer')\n      return {\n        type: 'noffer',\n        data: {\n          pubkey: bytesToHex(tlv[0][0]),\n          relay: utf8Decoder.decode(tlv[1][0]),\n          offer: utf8Decoder.decode(tlv[2][0]),\n          priceType: tlv[3][0][0],\n          price: tlv[4] ? parseInt(bytesToHex(tlv[4][0]), 16) : undefined\n        }\n      }\n    }\n    case 'ndebit': {\n      const tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for ndebit')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n      if (!tlv[1]?.[0]) throw new Error('missing TLV 1 for ndebit')\n      return {\n        type: 'ndebit',\n        data: {\n          pubkey: bytesToHex(tlv[0][0]),\n          relay: utf8Decoder.decode(tlv[1][0]),\n          pointer: tlv[2] ? utf8Decoder.decode(tlv[2][0]) : undefined\n        }\n      }\n    }\n    default:\n      throw new Error(`unknown prefix ${prefix}`)\n  }\n}\n\ntype TLV = { [t: number]: Uint8Array[] }\n\nfunction parseTLV(data: Uint8Array): TLV {\n  let result: TLV = {}\n  let rest = data\n  while (rest.length > 0) {\n    let t = rest[0]\n    let l = rest[1]\n    let v = rest.slice(2, 2 + l)\n    rest = rest.slice(2 + l)\n    if (v.length < l) throw new Error(`not enough data to read on TLV ${t}`)\n    result[t] = result[t] || []\n    result[t].push(v)\n  }\n  return result\n}\n\nexport function nsecEncode(key: Uint8Array): NSec {\n  return encodeBytes('nsec', key)\n}\n\nexport function npubEncode(hex: string): NPub {\n  return encodeBytes('npub', hexToBytes(hex))\n}\n\nexport function noteEncode(hex: string): Note {\n  return encodeBytes('note', hexToBytes(hex))\n}\n\nfunction encodeBech32<Prefix extends string>(prefix: Prefix, data: Uint8Array): `${Prefix}1${string}` {\n  let words = bech32.toWords(data)\n  return bech32.encode(prefix, words, Bech32MaxSize) as `${Prefix}1${string}`\n}\n\nexport function encodeBytes<Prefix extends string>(prefix: Prefix, bytes: Uint8Array): `${Prefix}1${string}` {\n  return encodeBech32(prefix, bytes)\n}\n\nexport function nprofileEncode(profile: ProfilePointer): NProfile {\n  let data = encodeTLV({\n    0: [hexToBytes(profile.pubkey)],\n    1: (profile.relays || []).map(url => utf8Encoder.encode(url)),\n  })\n  return encodeBech32('nprofile', data)\n}\n\nexport function neventEncode(event: EventPointer): NEvent {\n  let kindArray\n  if (event.kind !== undefined) {\n    kindArray = integerToUint8Array(event.kind)\n  }\n\n  let data = encodeTLV({\n    0: [hexToBytes(event.id)],\n    1: (event.relays || []).map(url => utf8Encoder.encode(url)),\n    2: event.author ? [hexToBytes(event.author)] : [],\n    3: kindArray ? [new Uint8Array(kindArray)] : [],\n  })\n\n  return encodeBech32('nevent', data)\n}\n\nexport function naddrEncode(addr: AddressPointer): NAddr {\n  let kind = new ArrayBuffer(4)\n  new DataView(kind).setUint32(0, addr.kind, false)\n\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map(url => utf8Encoder.encode(url)),\n    2: [hexToBytes(addr.pubkey)],\n    3: [new Uint8Array(kind)],\n  })\n  return encodeBech32('naddr', data)\n}\n\nexport const nofferEncode = (offer: OfferPointer): string => {\n  const o: TLV = {\n    0: [hexToBytes(offer.pubkey)],\n    1: [utf8Encoder.encode(offer.relay)],\n    2: [utf8Encoder.encode(offer.offer)],\n    3: [new Uint8Array([Number(offer.priceType)])],\n  }\n  if (offer.price) {\n    o[4] = [integerToUint8Array(offer.price)]\n  }\n  const data = encodeTLV(o)\n  const words = bech32.toWords(data)\n  return bech32.encode('noffer', words, 5000)\n}\n\nexport const ndebitEncode = (debit: DebitPointer): string => {\n  const o: TLV = {\n    0: [hexToBytes(debit.pubkey)],\n    1: [utf8Encoder.encode(debit.relay)],\n  }\n  if (debit.pointer) {\n    o[2] = [utf8Encoder.encode(debit.pointer)]\n  }\n  const data = encodeTLV(o)\n  const words = bech32.toWords(data)\n  return bech32.encode('ndebit', words, 5000)\n}\n\nfunction encodeTLV(tlv: TLV): Uint8Array {\n  let entries: Uint8Array[] = []\n\n  Object.entries(tlv)\n    .reverse()\n    .forEach(([t, vs]) => {\n      vs.forEach(v => {\n        let entry = new Uint8Array(v.length + 2)\n        entry.set([parseInt(t)], 0)\n        entry.set([v.length], 1)\n        entry.set(v, 2)\n        entries.push(entry)\n      })\n    })\n\n  return concatBytes(...entries)\n}\n", "import type { Event } from './core.ts'\n\nexport const utf8Decoder: TextDecoder = new TextDecoder('utf-8')\nexport const utf8Encoder: TextEncoder = new TextEncoder()\n\nexport function normalizeURL(url: string): string {\n  if (url.indexOf('://') === -1) url = 'wss://' + url\n  let p = new URL(url)\n  p.pathname = p.pathname.replace(/\\/+/g, '/')\n  if (p.pathname.endsWith('/')) p.pathname = p.pathname.slice(0, -1)\n  if ((p.port === '80' && p.protocol === 'ws:') || (p.port === '443' && p.protocol === 'wss:')) p.port = ''\n  p.searchParams.sort()\n  p.hash = ''\n  return p.toString()\n}\n\nexport function insertEventIntoDescendingList(sortedArray: Event[], event: Event): Event[] {\n  const [idx, found] = binarySearch(sortedArray, b => {\n    if (event.id === b.id) return 0\n    if (event.created_at === b.created_at) return -1\n    return b.created_at - event.created_at\n  })\n  if (!found) {\n    sortedArray.splice(idx, 0, event)\n  }\n  return sortedArray\n}\n\nexport function insertEventIntoAscendingList(sortedArray: Event[], event: Event): Event[] {\n  const [idx, found] = binarySearch(sortedArray, b => {\n    if (event.id === b.id) return 0\n    if (event.created_at === b.created_at) return -1\n    return event.created_at - b.created_at\n  })\n  if (!found) {\n    sortedArray.splice(idx, 0, event)\n  }\n  return sortedArray\n}\n\nexport function binarySearch<T>(arr: T[], compare: (b: T) => number): [number, boolean] {\n  let start = 0\n  let end = arr.length - 1\n\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2)\n    const cmp = compare(arr[mid])\n\n    if (cmp === 0) {\n      return [mid, true]\n    }\n\n    if (cmp < 0) {\n      end = mid - 1\n    } else {\n      start = mid + 1\n    }\n  }\n\n  return [start, false]\n}\n\nexport class QueueNode<V> {\n  public value: V\n  public next: QueueNode<V> | null = null\n  public prev: QueueNode<V> | null = null\n\n  constructor(message: V) {\n    this.value = message\n  }\n}\n\nexport class Queue<V> {\n  public first: QueueNode<V> | null\n  public last: QueueNode<V> | null\n\n  constructor() {\n    this.first = null\n    this.last = null\n  }\n\n  enqueue(value: V): boolean {\n    const newNode = new QueueNode(value)\n    if (!this.last) {\n      // list is empty\n      this.first = newNode\n      this.last = newNode\n    } else if (this.last === this.first) {\n      // list has a single element\n      this.last = newNode\n      this.last.prev = this.first\n      this.first.next = newNode\n    } else {\n      // list has elements, add as last\n      newNode.prev = this.last\n      this.last.next = newNode\n      this.last = newNode\n    }\n    return true\n  }\n\n  dequeue(): V | null {\n    if (!this.first) return null\n\n    if (this.first === this.last) {\n      const target = this.first\n      this.first = null\n      this.last = null\n      return target.value\n    }\n\n    const target = this.first\n    this.first = target.next\n\n    return target.value\n  }\n}\n", "import { AbstractSimplePool } from './abstract-pool.ts'\nimport { Subscription } from './abstract-relay.ts'\nimport type { Event, EventTemplate } from './core.ts'\nimport { fetchRelayInformation, RelayInformation } from './nip11.ts'\nimport { AddressPointer, decode } from './nip19.ts'\nimport { normalizeURL } from './utils.ts'\n\n/**\n * Represents a NIP29 group.\n */\nexport type Group = {\n  relay: string\n  metadata: GroupMetadata\n  admins?: GroupAdmin[]\n  members?: GroupMember[]\n  reference: GroupReference\n}\n\n/**\n * Represents the metadata for a NIP29 group.\n */\nexport type GroupMetadata = {\n  id: string\n  pubkey: string\n  name?: string\n  picture?: string\n  about?: string\n  isPublic?: boolean\n  isOpen?: boolean\n}\n\n/**\n * Represents a NIP29 group reference.\n */\nexport type GroupReference = {\n  id: string\n  host: string\n}\n\n/**\n * Represents a NIP29 group member.\n */\nexport type GroupMember = {\n  pubkey: string\n  label?: string\n}\n\n/**\n * Represents a NIP29 group admin.\n */\nexport type GroupAdmin = {\n  pubkey: string\n  label?: string\n  permissions: GroupAdminPermission[]\n}\n\n/**\n * Represents the permissions that a NIP29 group admin can have.\n */\nexport enum GroupAdminPermission {\n  AddUser = 'add-user',\n  EditMetadata = 'edit-metadata',\n  DeleteEvent = 'delete-event',\n  RemoveUser = 'remove-user',\n  AddPermission = 'add-permission',\n  RemovePermission = 'remove-permission',\n  EditGroupStatus = 'edit-group-status',\n}\n\n/**\n * Generates a group metadata event template.\n *\n * @param group - The group object.\n * @returns An event template with the generated group metadata that can be signed later.\n */\nexport function generateGroupMetadataEventTemplate(group: Group): EventTemplate {\n  const tags: string[][] = [['d', group.metadata.id]]\n  group.metadata.name && tags.push(['name', group.metadata.name])\n  group.metadata.picture && tags.push(['picture', group.metadata.picture])\n  group.metadata.about && tags.push(['about', group.metadata.about])\n  group.metadata.isPublic && tags.push(['public'])\n  group.metadata.isOpen && tags.push(['open'])\n\n  return {\n    content: '',\n    created_at: Math.floor(Date.now() / 1000),\n    kind: 39000,\n    tags,\n  }\n}\n\n/**\n * Validates a group metadata event.\n *\n * @param event - The event to validate.\n * @returns A boolean indicating whether the event is valid.\n */\nexport function validateGroupMetadataEvent(event: Event): boolean {\n  if (event.kind !== 39000) return false\n\n  if (!event.pubkey) return false\n\n  const requiredTags = ['d'] as const\n  for (const tag of requiredTags) {\n    if (!event.tags.find(([t]) => t == tag)) return false\n  }\n\n  return true\n}\n\n/**\n * Generates an event template for group admins.\n *\n * @param group - The group object.\n * @param admins - An array of group admins.\n * @returns The generated event template with the group admins that can be signed later.\n */\nexport function generateGroupAdminsEventTemplate(group: Group, admins: GroupAdmin[]): EventTemplate {\n  const tags: string[][] = [['d', group.metadata.id]]\n  for (const admin of admins) {\n    tags.push(['p', admin.pubkey, admin.label || '', ...admin.permissions])\n  }\n\n  return {\n    content: '',\n    created_at: Math.floor(Date.now() / 1000),\n    kind: 39001,\n    tags,\n  }\n}\n\n/**\n * Validates a group admins event.\n *\n * @param event - The event to validate.\n * @returns True if the event is valid, false otherwise.\n */\nexport function validateGroupAdminsEvent(event: Event): boolean {\n  if (event.kind !== 39001) return false\n\n  const requiredTags = ['d'] as const\n  for (const tag of requiredTags) {\n    if (!event.tags.find(([t]) => t == tag)) return false\n  }\n\n  // validate permissions\n  for (const [tag, _value, _label, ...permissions] of event.tags) {\n    if (tag !== 'p') continue\n\n    for (let i = 0; i < permissions.length; i += 1) {\n      if (typeof permissions[i] !== 'string') return false\n\n      // validate permission name from the GroupAdminPermission enum\n      if (!Object.values(GroupAdminPermission).includes(permissions[i] as GroupAdminPermission)) return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Generates an event template for a group with its members.\n *\n * @param group - The group object.\n * @param members - An array of group members.\n * @returns The generated event template with the group members that can be signed later.\n */\nexport function generateGroupMembersEventTemplate(group: Group, members: GroupMember[]): EventTemplate {\n  const tags: string[][] = [['d', group.metadata.id]]\n  for (const member of members) {\n    tags.push(['p', member.pubkey, member.label || ''])\n  }\n\n  return {\n    content: '',\n    created_at: Math.floor(Date.now() / 1000),\n    kind: 39002,\n    tags,\n  }\n}\n\n/**\n * Validates a group members event.\n *\n * @param event - The event to validate.\n * @returns Returns `true` if the event is a valid group members event, `false` otherwise.\n */\nexport function validateGroupMembersEvent(event: Event): boolean {\n  if (event.kind !== 39002) return false\n\n  const requiredTags = ['d'] as const\n  for (const tag of requiredTags) {\n    if (!event.tags.find(([t]) => t == tag)) return false\n  }\n\n  return true\n}\n\n/**\n * Returns the normalized relay URL based on the provided group reference.\n *\n * @param groupReference - The group reference object containing the host.\n * @returns The normalized relay URL.\n */\nexport function getNormalizedRelayURLByGroupReference(groupReference: GroupReference): string {\n  return normalizeURL(groupReference.host)\n}\n\n/**\n * Fetches relay information by group reference.\n *\n * @param groupReference The group reference.\n * @returns A promise that resolves to the relay information.\n */\nexport async function fetchRelayInformationByGroupReference(groupReference: GroupReference): Promise<RelayInformation> {\n  const normalizedRelayURL = getNormalizedRelayURLByGroupReference(groupReference)\n\n  return fetchRelayInformation(normalizedRelayURL)\n}\n\n/**\n * Fetches the group metadata event from the specified pool.\n * If the normalizedRelayURL is not provided, it will be obtained using the groupReference.\n * If the relayInformation is not provided, it will be fetched using the normalizedRelayURL.\n *\n * @param {Object} options - The options object.\n * @param {AbstractSimplePool} options.pool - The pool to fetch the group metadata event from.\n * @param {GroupReference} options.groupReference - The reference to the group.\n * @param {string} [options.normalizedRelayURL] - The normalized URL of the relay.\n * @param {RelayInformation} [options.relayInformation] - The relay information object.\n * @returns {Promise<Event>} The group metadata event that can be parsed later to get the group metadata object.\n * @throws {Error} If the group is not found on the specified relay.\n */\nexport async function fetchGroupMetadataEvent({\n  pool,\n  groupReference,\n  relayInformation,\n  normalizedRelayURL,\n}: {\n  pool: AbstractSimplePool\n  groupReference: GroupReference\n  normalizedRelayURL?: string\n  relayInformation?: RelayInformation\n}): Promise<Event> {\n  if (!normalizedRelayURL) {\n    normalizedRelayURL = getNormalizedRelayURLByGroupReference(groupReference)\n  }\n\n  if (!relayInformation) {\n    relayInformation = await fetchRelayInformation(normalizedRelayURL)\n  }\n\n  const groupMetadataEvent = await pool.get([normalizedRelayURL], {\n    kinds: [39000],\n    authors: [relayInformation.pubkey],\n    '#d': [groupReference.id],\n  })\n\n  if (!groupMetadataEvent) throw new Error(`group '${groupReference.id}' not found on ${normalizedRelayURL}`)\n\n  return groupMetadataEvent\n}\n\n/**\n * Parses a group metadata event and returns the corresponding GroupMetadata object.\n *\n * @param event - The event to parse.\n * @returns The parsed GroupMetadata object.\n * @throws An error if the group metadata event is invalid.\n */\nexport function parseGroupMetadataEvent(event: Event): GroupMetadata {\n  if (!validateGroupMetadataEvent(event)) throw new Error('invalid group metadata event')\n\n  const metadata: GroupMetadata = {\n    id: '',\n    pubkey: event.pubkey,\n  }\n\n  for (const [tag, value] of event.tags) {\n    switch (tag) {\n      case 'd':\n        metadata.id = value\n        break\n      case 'name':\n        metadata.name = value\n        break\n      case 'picture':\n        metadata.picture = value\n        break\n      case 'about':\n        metadata.about = value\n        break\n      case 'public':\n        metadata.isPublic = true\n        break\n      case 'open':\n        metadata.isOpen = true\n        break\n    }\n  }\n\n  return metadata\n}\n\n/**\n * Fetches the group admins event from the specified pool.\n * If the normalizedRelayURL is not provided, it will be obtained from the groupReference.\n * If the relayInformation is not provided, it will be fetched using the normalizedRelayURL.\n *\n * @param {Object} options - The options object.\n * @param {AbstractSimplePool} options.pool - The pool to fetch the group admins event from.\n * @param {GroupReference} options.groupReference - The reference to the group.\n * @param {string} [options.normalizedRelayURL] - The normalized relay URL.\n * @param {RelayInformation} [options.relayInformation] - The relay information.\n * @returns {Promise<Event>} The group admins event that can be parsed later to get the group admins object.\n * @throws {Error} If the group admins event is not found on the specified relay.\n */\nexport async function fetchGroupAdminsEvent({\n  pool,\n  groupReference,\n  relayInformation,\n  normalizedRelayURL,\n}: {\n  pool: AbstractSimplePool\n  groupReference: GroupReference\n  normalizedRelayURL?: string\n  relayInformation?: RelayInformation\n}): Promise<Event> {\n  if (!normalizedRelayURL) {\n    normalizedRelayURL = getNormalizedRelayURLByGroupReference(groupReference)\n  }\n\n  if (!relayInformation) {\n    relayInformation = await fetchRelayInformation(normalizedRelayURL)\n  }\n\n  const groupAdminsEvent = await pool.get([normalizedRelayURL], {\n    kinds: [39001],\n    authors: [relayInformation.pubkey],\n    '#d': [groupReference.id],\n  })\n\n  if (!groupAdminsEvent) throw new Error(`admins for group '${groupReference.id}' not found on ${normalizedRelayURL}`)\n\n  return groupAdminsEvent\n}\n\n/**\n * Parses a group admins event and returns an array of GroupAdmin objects.\n *\n * @param event - The event to parse.\n * @returns An array of GroupAdmin objects.\n * @throws Throws an error if the group admins event is invalid.\n */\nexport function parseGroupAdminsEvent(event: Event): GroupAdmin[] {\n  if (!validateGroupAdminsEvent(event)) throw new Error('invalid group admins event')\n\n  const admins: GroupAdmin[] = []\n\n  for (const [tag, value, label, ...permissions] of event.tags) {\n    if (tag !== 'p') continue\n\n    admins.push({\n      pubkey: value,\n      label,\n      permissions: permissions as GroupAdminPermission[],\n    })\n  }\n\n  return admins\n}\n\n/**\n * Fetches the group members event from the specified relay.\n * If the normalizedRelayURL is not provided, it will be obtained using the groupReference.\n * If the relayInformation is not provided, it will be fetched using the normalizedRelayURL.\n *\n * @param {Object} options - The options object.\n * @param {AbstractSimplePool} options.pool - The pool object.\n * @param {GroupReference} options.groupReference - The group reference object.\n * @param {string} [options.normalizedRelayURL] - The normalized relay URL.\n * @param {RelayInformation} [options.relayInformation] - The relay information object.\n * @returns {Promise<Event>} The group members event that can be parsed later to get the group members object.\n * @throws {Error} If the group members event is not found.\n */\nexport async function fetchGroupMembersEvent({\n  pool,\n  groupReference,\n  relayInformation,\n  normalizedRelayURL,\n}: {\n  pool: AbstractSimplePool\n  groupReference: GroupReference\n  normalizedRelayURL?: string\n  relayInformation?: RelayInformation\n}): Promise<Event> {\n  if (!normalizedRelayURL) {\n    normalizedRelayURL = getNormalizedRelayURLByGroupReference(groupReference)\n  }\n\n  if (!relayInformation) {\n    relayInformation = await fetchRelayInformation(normalizedRelayURL)\n  }\n\n  const groupMembersEvent = await pool.get([normalizedRelayURL], {\n    kinds: [39002],\n    authors: [relayInformation.pubkey],\n    '#d': [groupReference.id],\n  })\n\n  if (!groupMembersEvent) throw new Error(`members for group '${groupReference.id}' not found on ${normalizedRelayURL}`)\n\n  return groupMembersEvent\n}\n\n/**\n * Parses a group members event and returns an array of GroupMember objects.\n * @param event - The event to parse.\n * @returns An array of GroupMember objects.\n * @throws Throws an error if the group members event is invalid.\n */\nexport function parseGroupMembersEvent(event: Event): GroupMember[] {\n  if (!validateGroupMembersEvent(event)) throw new Error('invalid group members event')\n\n  const members: GroupMember[] = []\n\n  for (const [tag, value, label] of event.tags) {\n    if (tag !== 'p') continue\n\n    members.push({\n      pubkey: value,\n      label,\n    })\n  }\n\n  return members\n}\n\n/**\n * Fetches and parses the group metadata event, group admins event, and group members event from the specified pool.\n * If the normalized relay URL is not provided, it will be obtained using the group reference.\n * If the relay information is not provided, it will be fetched using the normalized relay URL.\n *\n * @param {Object} options - The options for loading the group.\n * @param {AbstractSimplePool} options.pool - The pool to load the group from.\n * @param {GroupReference} options.groupReference - The reference of the group to load.\n * @param {string} [options.normalizedRelayURL] - The normalized URL of the relay to use.\n * @param {RelayInformation} [options.relayInformation] - The relay information to use.\n * @returns {Promise<Group>} A promise that resolves to the loaded group.\n */\nexport async function loadGroup({\n  pool,\n  groupReference,\n  normalizedRelayURL,\n  relayInformation,\n}: {\n  pool: AbstractSimplePool\n  groupReference: GroupReference\n  normalizedRelayURL?: string\n  relayInformation?: RelayInformation\n}): Promise<Group> {\n  if (!normalizedRelayURL) {\n    normalizedRelayURL = getNormalizedRelayURLByGroupReference(groupReference)\n  }\n\n  if (!relayInformation) {\n    relayInformation = await fetchRelayInformation(normalizedRelayURL)\n  }\n\n  const metadataEvent = await fetchGroupMetadataEvent({ pool, groupReference, normalizedRelayURL, relayInformation })\n  const metadata = parseGroupMetadataEvent(metadataEvent)\n\n  const adminsEvent = await fetchGroupAdminsEvent({ pool, groupReference, normalizedRelayURL, relayInformation })\n  const admins = parseGroupAdminsEvent(adminsEvent)\n\n  const membersEvent = await fetchGroupMembersEvent({ pool, groupReference, normalizedRelayURL, relayInformation })\n  const members = parseGroupMembersEvent(membersEvent)\n\n  const group: Group = {\n    relay: normalizedRelayURL,\n    metadata,\n    admins,\n    members,\n    reference: groupReference,\n  }\n\n  return group\n}\n\n/**\n * Loads a group from the specified pool using the provided group code.\n *\n * @param {AbstractSimplePool} pool - The pool to load the group from.\n * @param {string} code - The code representing the group.\n * @returns {Promise<Group>} - A promise that resolves to the loaded group.\n * @throws {Error} - If the group code is invalid.\n */\nexport async function loadGroupFromCode(pool: AbstractSimplePool, code: string): Promise<Group> {\n  const groupReference = parseGroupCode(code)\n\n  if (!groupReference) throw new Error('invalid group code')\n\n  return loadGroup({ pool, groupReference })\n}\n\n/**\n * Parses a group code and returns a GroupReference object.\n *\n * @param code The group code to parse.\n * @returns A GroupReference object if the code is valid, otherwise null.\n */\nexport function parseGroupCode(code: string): null | GroupReference {\n  if (code.startsWith('naddr1')) {\n    try {\n      let { data } = decode(code)\n\n      let { relays, identifier } = data as AddressPointer\n      if (!relays || relays.length === 0) return null\n\n      let host = relays![0]\n      if (host.startsWith('wss://')) {\n        host = host.slice(6)\n      }\n      return { host, id: identifier }\n    } catch (err) {\n      return null\n    }\n  } else if (code.split(\"'\").length === 2) {\n    let spl = code.split(\"'\")\n    return { host: spl[0], id: spl[1] }\n  }\n\n  return null\n}\n\n/**\n * Encodes a group reference into a string.\n *\n * @param gr - The group reference to encode.\n * @returns The encoded group reference as a string.\n */\nexport function encodeGroupReference(gr: GroupReference): string {\n  const { host, id } = gr\n  const normalizedHost = host.replace(/^(https?:\\/\\/|wss?:\\/\\/)/, '')\n\n  return `${normalizedHost}'${id}`\n}\n\n/**\n * Subscribes to relay groups metadata events and calls the provided event handler function\n * when an event is received.\n *\n * @param {Object} options - The options for subscribing to relay groups metadata events.\n * @param {AbstractSimplePool} options.pool - The pool to subscribe to.\n * @param {string} options.relayURL - The URL of the relay.\n * @param {Function} options.onError - The error handler function.\n * @param {Function} options.onEvent - The event handler function.\n * @param {Function} [options.onConnect] - The connect handler function.\n * @returns {Function} - A function to close the subscription\n */\nexport function subscribeRelayGroupsMetadataEvents({\n  pool,\n  relayURL,\n  onError,\n  onEvent,\n  onConnect,\n}: {\n  pool: AbstractSimplePool\n  relayURL: string\n  onError: (err: Error) => void\n  onEvent: (event: Event) => void\n  onConnect?: () => void\n}): () => void {\n  let sub: Subscription\n\n  const normalizedRelayURL = normalizeURL(relayURL)\n\n  fetchRelayInformation(normalizedRelayURL)\n    .then(async info => {\n      const abstractedRelay = await pool.ensureRelay(normalizedRelayURL)\n\n      onConnect?.()\n\n      sub = abstractedRelay.prepareSubscription(\n        [\n          {\n            kinds: [39000],\n            limit: 50,\n            authors: [info.pubkey],\n          },\n        ],\n        {\n          onevent(event: Event) {\n            onEvent(event)\n          },\n        },\n      )\n    })\n    .catch(err => {\n      sub.close()\n\n      onError(err)\n    })\n\n  return () => sub.close()\n}\n"],
  "mappings": "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",
  "names": ["GroupAdminPermission"]
}
